$NetBSD: patch-ap,v 1.1.1.1 2001/04/27 15:27:31 agc Exp $

--- monster.c.orig	Fri Jun 19 13:55:33 1992
+++ monster.c	Sat Jan 13 20:21:51 2001
@@ -1,4 +1,5 @@
 /* monster.c */
+#include <stdlib.h>
 #include "header.h"
 #include "itm.h"
 #include "player.h"
@@ -88,7 +89,7 @@
  *
  * Enter with the monster number (1 to MAXMONST+8) Returns no value. 
  */
-createmonster(mon)
+void createmonster(mon)
 int             mon;
 {
 	int             x, y, k, i;
@@ -133,7 +134,7 @@
  * check for no monster at this location This routine will return FALSE if at
  * a wall or the dungeon exit on level 1 
  */
-cgood(x, y, itm, monst)
+int cgood(x, y, itm, monst)
 	int             x, y, itm, monst;
 {
 	if ((y >= 0) && (y <= MAXY - 1)
@@ -156,7 +157,7 @@
  * value, thus we don't know about createitem() failures. 
  *
  */
-createitem(x, y, it, arg)
+void createitem(x, y, it, arg)
 int             x,y, it, arg;
 {
 	int             k, i;
@@ -230,7 +231,7 @@
  */
 static char     eys[] = "\nEnter your spell: ";
 
-cast()
+void cast(void)
 {
 	int             i, j, a, b, d;
 
@@ -276,12 +277,14 @@
  * Enter with the spell number, returns no value. Please insure that there are 2
  * spaces before all messages here 
  */
-speldamage(x)
+void speldamage(x)
 int             x;
 {
 	int             i, j, clev;
 	int             xl, xh, yl, yh;
-	char          *it, *kn, *pm;
+	int		*pm;
+	int		*it;
+	char		*kn;
 	char           *s;
 
 	if (x >= SPNUM)
@@ -684,7 +687,7 @@
  * > 3 
  *
  */
-loseint()
+void loseint(void)
 {
 	if (--c[INTELLIGENCE] < 3)
 		c[INTELLIGENCE] = 3;
@@ -696,7 +699,7 @@
  * This routine prints out a message saying "You can't aim your magic!" returns
  * 0 if not confused, non-zero (time remaining confused) if confused 
  */
-isconfuse()
+int isconfuse(void)
 {
 	if (c[CONFUSE]) {
 		lprcat(" You can't aim your magic!");
@@ -713,7 +716,7 @@
  * returns 0 Enter with the spell number in x, and the monster number in
  * monst. 
  */
-nospell(x, monst)
+int nospell(x, monst)
 	int             x, monst;
 {
 	int             tmp;
@@ -737,7 +740,7 @@
  * Function to return hp damage to monster due to a number of full hits Enter
  * with the number of full hits being done 
  */
-fullhit(xx)
+int fullhit(xx)
 	int             xx;
 {
 	int             i;
@@ -760,7 +763,7 @@
  * the spell number in spnum, the damage to be done in dam, lprintf format
  * string in str, and lprintf's argument in arg. Returns no value. 
  */
-direct(spnum, dam, str, arg)
+void direct(spnum, dam, str, arg)
 	int             spnum, dam, arg;
 	char           *str;
 {
@@ -822,11 +825,11 @@
  * str, the # of milliseconds to delay between locations in delay, and the
  * character to represent the weapon in cshow. Returns no value. 
  */
-godirect(spnum, dam, str, delay, cshow)
+void godirect(spnum, dam, str, delay, cshow)
 int             spnum, dam, delay;
 char           *str, cshow;
 {
-	char          *it;
+	int		*it;
 	int             x, y, m;
 	int             dx, dy;
 
@@ -967,7 +970,7 @@
  * Subroutine to copy the word "monster" into lastmonst if the player is blind.
  * Enter with the coordinates (x,y) of the monster Returns no value. 
  */
-ifblind(x, y)
+void ifblind(x, y)
 	int             x, y;
 {
 	char           *s;
@@ -989,7 +992,7 @@
  * Routine to ask for a direction to a spell and then teleport away monster
  * Enter with the spell number that wants to teleport away Returns no value. 
  */
-tdirect(spnum)
+void tdirect(spnum)
 	int             spnum;
 {
 	int             x, y;
@@ -1014,7 +1017,7 @@
 }
 
 
-makewall(spnum)
+void makewall(spnum)
 	int             spnum;
 {
 	int             x, y;
@@ -1025,7 +1028,12 @@
 		return;
 	dirsub(&x, &y);
 
-	if ((y >= 0) && (y <= MAXY - 1) && (x >= 0) && (x <= MAXX - 1))	/* within bounds? */
+	/* within bounds? */
+	if (	y >= 0 &&
+		y <= MAXY - 1 &&
+		x >= 0 &&
+		x <= MAXX - 1)
+	{
 		if (item[x][y] != OWALL) {	/* can't make anything on
 						 * walls */
 			if (item[x][y] == 0) {	/* is it free of items? */
@@ -1035,14 +1043,19 @@
 						item[x][y] = OWALL;
 						know[x][y] = 1;
 						show1cell(x, y);
-					} else
+					} else {
 						lprcat("\nyou can't make a wall there!");
-				} else
+					}
+				} else {
 					lprcat("\nthere's a monster there!");
-			} else
+				}
+			} else {
 				lprcat("\nthere's something there already!");
-		} else
+			}
+		} else {
 			lprcat("\nthere's a wall there already!");
+		}
+	}
 }
 
 /*
@@ -1054,7 +1067,7 @@
  * the spell number in sp, the damage done to wach square in dam, and the
  * lprintf string to identify the spell in str. Returns no value. 
  */
-omnidirect(spnum, dam, str)
+void omnidirect(spnum, dam, str)
 	int             spnum, dam;
 	char           *str;
 {
@@ -1062,9 +1075,9 @@
 
 	if (spnum < 0 || spnum >= SPNUM || str == 0)
 		return;		/* bad args */
-	for (x = playerx - 1; x < playerx + 2; x++)
+	for (x = playerx - 1; x < playerx + 2; x++) {
 		for (y = playery - 1; y < playery + 2; y++) {
-			if ((m = mitem[x][y].mon) != 0)
+			if ((m = mitem[x][y].mon) != 0) {
 				if (nospell(spnum, m) == 0) {
 					ifblind(x, y);
 					cursors();
@@ -1076,7 +1089,9 @@
 					lasthx = x;
 					lasthy = y;
 				}
+			}
 		}
+	}
 }
 
 /*
@@ -1087,7 +1102,7 @@
  * with the origination coordinates in (x,y). Returns index into diroffx[]
  * (0-8). 
  */
-dirsub(x, y)
+int dirsub(x, y)
 	int            *x, *y;
 {
 	int             i;
@@ -1130,7 +1145,7 @@
  * level. Returns TRUE if it was out of bounds, and the *x & *y in the
  * calling routine are affected. 
  */
-verifyxy(x, y)
+int verifyxy(x, y)
 int            *x, *y;
 {
 	int             flag = 0;
@@ -1162,7 +1177,7 @@
  * Subroutine to polymorph a monster and ask for the direction its in Enter with
  * the spell number in spmun. Returns no value. 
  */
-dirpoly(spnum)
+void dirpoly(spnum)
 	int             spnum;
 {
 	int             x, y, m;
@@ -1194,7 +1209,7 @@
  * This routine is used for a bash & slash type attack on a monster Enter with
  * the coordinates of the monster in (x,y). Returns no value. 
  */
-hitmonster(x, y)
+void hitmonster(x, y)
 int             x, y;
 {
 	int             tmp, monst, damag, flag;
@@ -1231,11 +1246,14 @@
 
 	/* if the monster was hit */
 	if (flag) {
-		if (iven[c[WIELD]] != OSWORDofSLASHING)
+		if (iven[c[WIELD]] != OSWORDofSLASHING) {
 			/* if a "dulling" monster */
-			if (monst == RUSTMONSTER || monst == DISENCHANTRESS || monst == CUBE)
+			if (	monst == RUSTMONSTER ||
+				monst == DISENCHANTRESS ||
+				monst == CUBE)
+			{
 				/* if we are wielding something */
-				if (c[WIELD] > 0)
+				if (c[WIELD] > 0) {
 					/* if it's not already dulled to hell */
 					if (((ivenarg[c[WIELD]] > -10) &&
 					     ((iven[c[WIELD]] == OSLAYER) ||
@@ -1248,7 +1266,8 @@
 					      (iven[c[WIELD]] == OLANCE) ||
 					      (iven[c[WIELD]] == OHAMMER) ||
 					      (iven[c[WIELD]] == OBELT)))
-					    || (ivenarg[c[WIELD]] > 0)) {
+					    || (ivenarg[c[WIELD]] > 0))
+					{
 						lprintf("\nYour weapon is dulled by the %s", lastmonst);
 						beep();
 						--ivenarg[c[WIELD]];
@@ -1257,6 +1276,9 @@
 						iven[c[WIELD]] = ivenarg[c[WIELD]] = 0;
 						c[WIELD] = 0;
 					}
+				}
+			}
+		}
 	}
 	if (flag) {
 		hitm(x, y, damag);
@@ -1271,7 +1293,7 @@
 			show1cell(x, y);
 		}
 	if (mitem[x][y].mon == LEMMING)
-		if (rnd(100) <= 40)
+		if (rnd(100) <= 10)
 			createmonster(LEMMING);
 }
 
@@ -1284,7 +1306,7 @@
  * specifically damage a monster at a location (x,y) Called by
  * hitmonster(x,y) 
  */
-hitm(x, y, amt)
+int hitm(x, y, amt)
 int x, y, amt;
 {
 	int             monst;
@@ -1369,7 +1391,7 @@
  *	Function for the monster to hit the player with monster at location x,y
  *	Returns nothing of value.
  */
-hitplayer (x, y)
+void hitplayer (x, y)
 int x, y;
 {
 	register int dam,tmp,mster,bias;
@@ -1465,7 +1487,7 @@
  *	Enter with the monster number 
  *	Returns nothing of value.
  */
-dropsomething (x,y,monst)
+void dropsomething (x,y,monst)
 int x,y;
 int monst;
 {
@@ -1495,7 +1517,7 @@
  *
  * Enter with the number of gold pieces to drop Returns nothing of value. 
  */
-dropgold(amount)
+void dropgold(amount)
 int amount;
 {
 	if (amount > 250)
@@ -1512,7 +1534,7 @@
  * with the cave level on which something is to be dropped Returns nothing of
  * value. 
  */
-something(x,y,lev)
+void something(x,y,lev)
 int x,y,lev;
 {
 	int j, i;
@@ -1544,7 +1566,7 @@
 		OSPEAR, OBELT, ORING, OSTUDLEATHER, OSHIELD, OFLAIL, OCHAIN,
 			     O2SWORD, OPLATE, OLONGSWORD};	/* 38 */
 
-newobject(lev, i)
+int newobject(lev, i)
 int             lev, *i;
 {
 int             tmp = 32, j;
@@ -1671,18 +1693,19 @@
  */
 #define ARMORTYPES 6
 
-static short    rustarm[ARMORTYPES][2] = {
-					  OSTUDLEATHER, -2,
-					  ORING, -4,
-					  OCHAIN, -5,
-					  OSPLINT, -6,
-					  OPLATE, -8,
-					  OPLATEARMOR, -9
+static short    rustarm[ARMORTYPES][2] =
+{
+	{ OSTUDLEATHER, -2 },
+	{ ORING, -4 },
+	{ OCHAIN, -5 },
+	{ OSPLINT, -6 },
+	{ OPLATE, -8 },
+	{ OPLATEARMOR, -9 },
 };
 
 static char     spsel[] = {1, 2, 3, 5, 6, 8, 9, 11, 13, 14};
 
-spattack(x, xx, yy)
+int spattack(x, xx, yy)
 int             x, xx, yy;
 {
 	int             i, j = 0, k, m;
@@ -1693,12 +1716,14 @@
 	/*
 	 * cancel only works 5% of time for demon prince and god 
 	 */
-	if (c[CANCELLATION])
+	if (c[CANCELLATION]) {
 		if (mitem[xx][yy].mon >= DEMONPRINCE) {
 			if (rnd(100) >= 95)
 				return (0);
-		} else
+		} else {
 			return (0);
+		}
+	}
 
 	/* staff of power cancels demonlords/wraiths/vampires 75% of time */
 	/* lucifer is unaffected */
@@ -1921,7 +1946,7 @@
  * Enter with the number of hit points to lose Note: if x > c[HP] this routine
  * could kill the player! 
  */
-checkloss(x)
+void checkloss(x)
 	int             x;
 {
 	if (x > 0) {
@@ -1937,16 +1962,17 @@
  * Gives player experience, but no dropped objects Returns the experience gained
  * from all monsters killed 
  */
-annihilate()
+void annihilate(void)
 {
 	int             i, j;
 	long            k;
-	char          *p;
+	int		*p;
 
-	for (k = 0, i = playerx - 1; i <= playerx + 1; i++)
-	    for (j = playery - 1; j <= playery + 1; j++)
-		if (!verifyxy(&i, &j))	/* if not out of bounds */
-		    if (*(p = &mitem[i][j].mon))	/* if a monster there */
+	for (k = 0, i = playerx - 1; i <= playerx + 1; i++) {
+	    for (j = playery - 1; j <= playery + 1; j++) {
+		if (!verifyxy(&i, &j)) {	/* if not out of bounds */
+		    p = &mitem[i][j].mon;
+		    if (*p) {			/* if a monster there */
 			if (*p < DEMONLORD) {
 				k += monster[*p].experience;
 				*p = know[i][j] = 0;
@@ -1956,6 +1982,10 @@
 				/* lose half hit points */
 				hitp[i][j] = (hitp[i][j] >> 1) + 1;
 			}
+		    }
+		}
+	    }
+	}
 	if (k > 0) {
 		lprcat("\nYou hear loud screams of agony!");
 		raiseexperience((long) k);
@@ -1967,7 +1997,7 @@
  *
  * This is done by setting a flag in the monster[] structure 
  */
-genmonst()
+void genmonst(void)
 {
 	int  i, j;
 
@@ -1996,7 +2026,7 @@
  * function to return monster number for a randomly selected monster for the
  * given cave level	 
  */
-makemonst(lev)
+int makemonst(lev)
 int             lev;
 {
 	int             tmp, x;
@@ -2028,7 +2058,7 @@
 /*
 	subroutine to randomly create monsters if needed
  */
-randmonst ()
+void randmonst (void)
 {	/*	don't make monsters if time is stopped	*/
 	if (c[TIMESTOP]) 
 		return;
