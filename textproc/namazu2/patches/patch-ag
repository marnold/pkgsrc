$NetBSD: patch-ag,v 1.1.1.1.4.1 2002/09/05 09:56:13 agc Exp $

--- nmz/regex.c.orig	Sat Sep  1 18:40:52 2001
+++ nmz/regex.c
@@ -71,6 +71,12 @@
 void free _((void*));
 #endif
 
+#ifdef HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
 /* #define	NO_ALLOCA */	/* try it out for now */
 #ifndef NO_ALLOCA
 /* Make alloca work the best possible way.  */
@@ -99,12 +105,6 @@
 # endif
 #endif /* __GNUC__ */
 
-#ifdef HAVE_STRING_H
-# include <string.h>
-#else
-# include <strings.h>
-#endif
-
 #define RE_ALLOCATE alloca
 #ifdef C_ALLOCA
 #define FREE_VARIABLES() alloca(0)
@@ -153,7 +153,9 @@
 static void insert_jump _((int, char*, char*, char*));
 static void store_jump_n _((char*, int, char*, unsigned));
 static void insert_jump_n _((int, char*, char*, char*, unsigned));
+#if 0
 static void insert_op _((int, char*, char*));
+#endif
 static void insert_op_2 _((int, char*, char*, int, int));
 static int memcmp_translate _((unsigned char*, unsigned char*, int));
 
@@ -175,9 +177,7 @@
 
 #undef P
 
-#ifdef RUBY
 #include "util.h"
-#endif
 
 static void
 init_syntax_once()
@@ -358,7 +358,7 @@
     wordbeg,	 /* Succeeds if at word beginning.  */
     wordend,	 /* Succeeds if at word end.  */
     wordbound,   /* Succeeds if at a word boundary.  */
-    notwordbound,/* Succeeds if not at a word boundary.  */
+    notwordbound /* Succeeds if not at a word boundary.  */
   };
 
 
@@ -409,6 +409,7 @@
   long syntax;
 {
     /* obsolete */
+    return 0;
 }
 
 
@@ -442,7 +443,7 @@
       int n = mbclen(c) - 1;						\
       c &= (1<<(BYTEWIDTH-2-n)) - 1;					\
       while (n--) {							\
-	c = c << 6 | *p++ & ((1<<6)-1);					\
+	c = (c << 6) | (*p++ & ((1<<6)-1));				\
       }									\
     }									\
     else {								\
@@ -483,23 +484,28 @@
 {
   if (current_mbctype == MBCTYPE_UTF8) {
     if (c < 0x80)
-      printf("%c", c);
+      printf("%c", (int)c);
     else if (c <= 0x7ff)
-      printf("%c%c", utf8_firstbyte(c), c&0x3f);
+      printf("%c%c", (int)utf8_firstbyte(c), (int)(c & 0x3f));
     else if (c <= 0xffff)
-      printf("%c%c%c", utf8_firstbyte(c), (c>>6)&0x3f, c&0x3f);
+      printf("%c%c%c", (int)utf8_firstbyte(c), (int)((c >> 6) & 0x3f),
+	     (int)(c & 0x3f));
     else if (c <= 0x1fffff) 
-      printf("%c%c%c%c", utf8_firstbyte(c), (c>>12)&0x3f, (c>>6)&0x3f, c&0x3f);
+      printf("%c%c%c%c", (int)utf8_firstbyte(c), (int)((c >> 12) & 0x3f),
+	     (int)((c >> 6) & 0x3f), (int)(c & 0x3f));
     else if (c <= 0x3ffffff)
-      printf("%c%c%c%c%c", utf8_firstbyte(c), (c>>18)&0x3f, (c>>12)&0x3f, (c>>6)&0x3f, c&0x3f);
+      printf("%c%c%c%c%c", (int)utf8_firstbyte(c), (int)((c >> 18) & 0x3f),
+	     (int)((c >> 12) & 0x3f), (int)((c >> 6) & 0x3f), (int)(c & 0x3f));
     else if (c <= 0x7fffffff)
-      printf("%c%c%c%c%c%c", utf8_firstbyte(c), (c>>24)&0x3f, (c>>18)&0x3f, (c>>12)&0x3f, (c>>6)&0x3f, c&0x3f);
+      printf("%c%c%c%c%c%c", (int)utf8_firstbyte(c), (int)((c >> 24) & 0x3f),
+	     (int)((c >> 18) & 0x3f), (int)((c >> 12) & 0x3f),
+	     (int)((c >> 6) & 0x3f), (int)(c & 0x3f));
   }
   else if (c < 0xff) {
-    printf("\\%o", c);
+    printf("\\%o", (int)c);
   }
   else {
-    printf("%c%c", c>>BYTEWIDTH, c&0xff);
+    printf("%c%c", (int)(c >> BYTEWIDTH), (int)(c &0xff));
   }
 }
 
@@ -700,6 +706,7 @@
   return 0;
 }
 
+#if 0
 static void
 print_partial_compiled_pattern(start, end)
     unsigned char *start;
@@ -949,6 +956,7 @@
 
   print_partial_compiled_pattern (buffer, buffer + bufp->used);
 }
+#endif
 
 static char*
 calculate_must_string(start, end)
@@ -1118,7 +1126,7 @@
   register const char *p = pattern;
   const char *nextp;
   const char *pend = pattern + size;
-  register unsigned int c, c1;
+  register unsigned int c, c1 = 0;
   const char *p0;
   int numlen;
 
@@ -1412,8 +1420,8 @@
 	  case 'W':
 	    for (c = 0; c < (1 << BYTEWIDTH); c++) {
 	      if (SYNTAX(c) != Sword &&
-		  (current_mbctype && !re_mbctab[c] ||
-		  !current_mbctype && SYNTAX(c) != Sword2))
+		  ((current_mbctype && !re_mbctab[c]) ||
+		   (!current_mbctype && SYNTAX(c) != Sword2)))
 		SET_LIST_BIT(c);
 	    }
 	    last = -1;
@@ -2241,6 +2249,8 @@
 	case dummy_failure_jump:
 	  bufp->options |= RE_OPTIMIZE_ANCHOR;
 	  break;
+	default:
+	  break;
 	}
       }
       else if (*laststart == charset || *laststart == charset_not) {
@@ -2409,6 +2419,7 @@
 }
 
 
+#if 0
 /* Open up space at location THERE, and insert operation OP.
    CURRENT_END gives the end of the storage in use, so
    we know how much data to copy up.
@@ -2428,7 +2439,7 @@
 
   there[0] = (char)op;
 }
-
+#endif
 
 /* Open up space at location THERE, and insert operation OP followed by
    NUM_1 and NUM_2.  CURRENT_END gives the end of the storage in use, so
@@ -4095,7 +4106,6 @@
 	p1 = p;
 	/* If failed to a backwards jump that's part of a repetition
 	   loop, need to pop this failure point and use the next one.  */
-      pop_loop:
 	switch ((enum regexpcode)*p1) {
 	case jump_n:
 	case finalize_push_n:
