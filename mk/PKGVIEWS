$NetBSD: PKGVIEWS,v 1.1.2.4 2003/07/29 20:37:50 jlam Exp $

Package views integration plan:
==============================

(1) Modify pkgsrc internals (bsd.pkg.mk & friends) to build and
    install depoted packages if PKG_INSTALLATION_TYPE is set to
    "pkgviews" in the package Makefile, and to add the depoted
    package to the default view.  The depoted package will include
    all of it's metadata files in the depot directory, and we rely
    on pkg_view to copy the metadata files into /var/db/pkg as
    part of adding the package to the default view.  We only
    support the default view.  Depoted packages will install into
    either ${LOCALBASE}/packages or ${X11BASE}/packages, but the
    default view will be through ${LOCALBASE} for all packages.

Using this infrastructure, depoted packages that have been added to
the default view should look and feel like a non-depoted package in
all respects, down to what you find in /var/db/pkg/${PKGNAME}, so
non-depoted packages can depend on depoted packages without change.

(2) Migrate packages set PKG_INSTALLATION_TYPE to "pkgviews".
    Depoted packages can only depend on other depoted packages.  A
    depoted package will have <deppkg_dir>/lib and ${LOCALBASE}/lib
    in the run-time library search path (-Wl,-R*) so that wildcard
    dependencies on library packages will still work (so long as
    the major number of the shlib hasn't increased).

At this point, all packages in pkgsrc will be depoted, and we can
unconditionally set PKG_INSTALLATION_TYPE to "pkgviews" for all of
pkgsrc.  We don't actually require that xpkgwedge be used since
depoted packages can live anywhere, and it's up to pkg_view(1) to
add the depoted package to the default view.

(3) Allow for different package views.  At this point, this step
    should be trivial.

Possible problems:
-----------------

(1) I may be wrong about xpkgwedge.  We may need some sort of
    xpkgwedge package in order to properly handle USE_IMAKE packages
    so that they install into depot directories, but I'm ignoring them
    for now, or at least until we get much further along on step (2).
    Also, I'll figure out how to deal with binary packages later on.

(2) INSTALL scripts currently do several things.  The main things
    nowadays are to handle: users/groups, config files, directories,
    info files, and shell registration.  There are some things that we
    only want to happen once, when the package is installed into its
    depot directory: handling users/group creation, config files, and
    non-${PREFIX} directories.  There are some things that we want to
    happen every time a package is added to a view: adding info files
    to info/dir and shell registration.

(3) DEINSTALL scripts also do several things.  The main things are to
    remove: config files, directories, info files, and de-register
    shells.  We only want some things to happen once when the package
    is pkg_delete'd from it's depot directory: removing config files
    and non-${PREFIX} directories.  We want some things to happen every
    time a package is removed from a view: removing info file entries
    from info/dir and de-registering shells.

(4) The last step that pkg_delete(1) does is
    "rm -r ${PKG_DBDIR}/${PKGNAME}", which is a cleanup step that
    avoids problems of undeleted temp files hanging around in the
    directory and preventing a clean removal of the package when
    PKG_DBDIR is "/var/db/pkg".  This is key behaviour that we should
    preserve for when we use pkg_delete(1) to remove a package from a
    view.  I can enhance pkg_delete to do an alternative cleanup step
    of just removing all of the package metafiles if it's the package
    in its depot directory (I can test for the presence of +VIEWS),
    and then have pkg_delete(1) note that it can't remove the
    ${PKGNAME} directory because it's nonempty.
