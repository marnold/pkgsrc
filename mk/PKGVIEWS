$NetBSD: PKGVIEWS,v 1.1.2.3 2003/07/24 23:19:00 jlam Exp $

Package views integration plan:
==============================

(1) Modify pkgsrc internals (bsd.pkg.mk & friends) to build and
    install depoted packages if PKG_INSTALLATION_TYPE is set to
    "pkgviews" in the package Makefile, and to add the depoted
    package to the default view.  The depoted package will include
    all of it's metadata files in the depot directory, and we rely
    on pkg_view to copy the metadata files into /var/db/pkg as
    part of adding the package to the default view.  We only
    support the default view.  Depoted packages will install into
    either ${LOCALBASE}/packages or ${X11BASE}/packages, but the
    default view will be through ${LOCALBASE} for all packages.

Using this infrastructure, depoted packages that have been added to
the default view should look and feel like a non-depoted package in
all respects, down to what you find in /var/db/pkg/${PKGNAME}, so
non-depoted packages can depend on depoted packages without change.

(2) Migrate packages set PKG_INSTALLATION_TYPE to "pkgviews".
    Depoted packages can only depend on other depoted packages.  A
    depoted package will have <deppkg_dir>/lib and ${LOCALBASE}/lib
    in the run-time library search path (-Wl,-R*) so that wildcard
    dependencies on library packages will still work (so long as
    the major number of the shlib hasn't increased).

At this point, all packages in pkgsrc will be depoted, and we can
unconditionally set PKG_INSTALLATION_TYPE to "pkgviews" for all of
pkgsrc.  We don't actually require that xpkgwedge be used since
depoted packages can live anywhere, and it's up to pkg_view(1) to
add the depoted package to the default view.

(3) Allow for different package views.  At this point, this step
    should be trivial.

Possible problems:
-----------------

(1) I may be wrong about xpkgwedge.  We may need some sort of
    xpkgwedge package in order to properly handle USE_IMAKE packages
    so that they install into depot directories, but I'm ignoring them
    for now, or at least until we get much further along on step (2).
    Also, I'll figure out how to deal with binary packages later on.

(2) INSTALL scripts currently do several things.  The main things
    nowadays are to handle: users/groups, config files, directories,
    info files, and shell registration.  There are some things that we
    only want to happen once, when the package is installed into its
    depot directory: handling users/group creation, config files, and
    non-${PREFIX} directories.  There are some things that we want to
    happen every time a package is added to a view: adding info files
    to info/dir and shell registration.

(3) DEINSTALL scripts also do several things.  The main things are to
    remove: config files, directories, info files, and de-register
    shells.  We only want some things to happen once when the package
    is pkg_delete'd from it's depot directory: removing config files
    and non-${PREFIX} directories.  We want some things to happen every
    time a package is removed from a view: removing info file entries
    from info/dir and de-registering shells.

> => I don't really agree here. $PREFIX is the base dir from where
> a package is supposed to be run from.
> So I think PKG_SYSCONFBASE must be PREFIX/etc. I surely mean that
> PKG_SYSCONFBASE can't really be a user setable variable anymore.

I think there may be some knashing of teeth if we make
PKG_SYSCONFBASE non-tweakable.  I think it'll be okay to leave it as
user-settable, but that users should be made aware that this restricts
them from having the full flexibility allowed by pkgviews.  This is,
of course, moot for the integration effort, since we won't be
supporting multiple views until later.

> Example config file copy is definitively a POST-INSTALL op.
> Symlinks to $PREFIX/etc from VIEW/etc should be made of course as a
> convenient knob of course. 

I'm trying to see how they interact with dynamic PLISTs, which are
generated _after_ all of the INSTALL script actions are run.  If we
copy all of the config files into place (into $PREFIX/etc), then
they'll all be stored into the the PLIST when it's generated, so when
the package is deleted, pkg_delete(1) will generate warnings that the
customized config files have been modified and won't be removed, so
the pkg_delete will be unsuccessful.  I don't think we want this.  I
can certainly move the dynamic PLIST generation a little earlier so
that it occurs before "make post-install-script" is executed during
the "make install" process, but I'm not sure if this will break
anything (although I don't think it will).

I'm happy with your argument, though, and I'll start my initial
integration work with leaving the config file copies as a POST-INSTALL
operation (which is actually much easier than my proposed change).

> Then for the modified config file not deleted problem perhaps we
> should come up with something new. Something along the mutable flag
> of svr4 pkg inventory perhaps and perhaps adding a token in the
> depotted dir stating that this pkg is not really longer installed but
> some file are stilll there because of the intend to preserve modified
> config file. Well perhaps only the fact that there is no other
> metafiles left in PREFIX would be enough to mean just that.

The last step that pkg_delete(1) does is "rm -r ${PKG_DBDIR}/${PKGNAME}",
which is a cleanup step that avoids problems of undeleted temp files
hanging around in the directory and preventing a clean removal of the
package when PKG_DBDIR is "/var/db/pkg".  This is key behaviour that
we should preserve for when we use pkg_delete(1) to remove a package
from a view.  I can enhance pkg_delete to do an alternative cleanup
step of just removing all of the package metafiles if it's the package
in its depot directory (I can test for the presence of +VIEWS), and
then have pkg_delete(1) note that it can't remove the ${PKGNAME}
directory because it's nonempty.
