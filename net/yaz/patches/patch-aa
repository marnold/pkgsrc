$NetBSD: patch-aa,v 1.1.1.1 2003/05/16 12:17:27 dmcmahill Exp $

These patches are needed to avoid unaligned accesses on 64 bit
systems.

--- util/xmalloc.c.orig	Mon Jan  6 08:20:28 2003
+++ util/xmalloc.c
@@ -23,9 +23,9 @@
 
 #if TRACE_XMALLOC > 1
 
-static const unsigned char head[] = {44, 33, 22, 11};
-static const unsigned char tail[] = {11, 22, 33, 44};
-static const unsigned char freed[] = {11, 22, 33, 44};
+static const unsigned char head[] = {88, 77, 66, 55, 44, 33, 22, 11};
+static const unsigned char tail[] = {11, 22, 33, 44, 55, 66, 77, 88};
+static const unsigned char freed[] = {11, 22, 33, 44, 55, 66, 77, 88};
 
 struct dmalloc_info {
     int len;
@@ -42,7 +42,7 @@ void *xmalloc_d(size_t nbytes, const cha
     char *res;
     struct dmalloc_info *dinfo;
     
-    if (!(res = (char*) malloc(nbytes + sizeof(*dinfo)+8*sizeof(char))))
+    if (!(res = (char*) malloc(nbytes + sizeof(*dinfo)+16*sizeof(char))))
 	return 0;
     dinfo = (struct dmalloc_info *) res;
     strncpy (dinfo->file, file, sizeof(dinfo->file)-1);
@@ -56,9 +56,9 @@ void *xmalloc_d(size_t nbytes, const cha
 	dinfo->next->prev = dinfo;
     dmalloc_list = dinfo;
     
-    memcpy(res + sizeof(*dinfo), head, 4*sizeof(char));
-    res += sizeof(*dinfo) + 4*sizeof(char);
-    memcpy(res + nbytes, tail, 4*sizeof(char));
+    memcpy(res + sizeof(*dinfo), head, 8*sizeof(char));
+    res += sizeof(*dinfo) + 8*sizeof(char);
+    memcpy(res + nbytes, tail, 8*sizeof(char));
     return res;
 }
 
@@ -69,13 +69,13 @@ void xfree_d(void *ptr, const char *file
     if (!ptr)
 	return;
     dinfo = (struct dmalloc_info *)
-	((char*)ptr - 4*sizeof(char) - sizeof(*dinfo));
-    if (memcmp(head, (char*) ptr - 4*sizeof(char), 4*sizeof(char)))
+	((char*)ptr - 8*sizeof(char) - sizeof(*dinfo));
+    if (memcmp(head, (char*) ptr - 8*sizeof(char), 8*sizeof(char)))
     {
 	yaz_log(LOG_FATAL, "xfree_d bad head, %s:%d, %p", file, line, ptr);
         abort();
     }
-    if (memcmp((char*) ptr + dinfo->len, tail, 4*sizeof(char)))
+    if (memcmp((char*) ptr + dinfo->len, tail, 8*sizeof(char)))
     {
 	yaz_log(LOG_FATAL, "xfree_d bad tail, %s:%d, %p", file, line, ptr);
         abort();
@@ -86,7 +86,7 @@ void xfree_d(void *ptr, const char *file
 	dmalloc_list = dinfo->next;
     if (dinfo->next)
 	dinfo->next->prev = dinfo->prev;
-    memcpy ((char*) ptr - 4*sizeof(char), freed, 4*sizeof(char));
+    memcpy ((char*) ptr - 8*sizeof(char), freed, 8*sizeof(char));
     free(dinfo);
     return;
 }
@@ -101,18 +101,18 @@ void *xrealloc_d(void *p, size_t nbytes,
     {
 	if (!nbytes)
 	    return 0;
-	res = (char *) malloc(nbytes + sizeof(*dinfo) + 8*sizeof(char));
+	res = (char *) malloc(nbytes + sizeof(*dinfo) + 16*sizeof(char));
     }
     else
     {
-	if (memcmp(head, ptr - 4*sizeof(char), 4*sizeof(char)))
+	if (memcmp(head, ptr - 8*sizeof(char), 8*sizeof(char)))
 	{
 	    yaz_log(LOG_FATAL, "xrealloc_d bad head, %s:%d, %p",
 		    file, line, ptr);
 	    abort();
 	}
-	dinfo = (struct dmalloc_info *) (ptr-4*sizeof(char) - sizeof(*dinfo));
-	if (memcmp(ptr + dinfo->len, tail, 4*sizeof(char)))
+	dinfo = (struct dmalloc_info *) (ptr-8*sizeof(char) - sizeof(*dinfo));
+	if (memcmp(ptr + dinfo->len, tail, 8*sizeof(char)))
 	{
 	    yaz_log(LOG_FATAL, "xrealloc_d bad tail, %s:%d, %p",
 		    file, line, ptr);
@@ -131,7 +131,7 @@ void *xrealloc_d(void *p, size_t nbytes,
 	    return 0;
 	}
 	res = (char *)
-	    realloc(dinfo, nbytes + sizeof(*dinfo) + 8*sizeof(char));
+	    realloc(dinfo, nbytes + sizeof(*dinfo) + 16*sizeof(char));
     }
     if (!res)
 	return 0;
@@ -147,9 +147,9 @@ void *xrealloc_d(void *p, size_t nbytes,
 	dmalloc_list->prev = dinfo;
     dmalloc_list = dinfo;
     
-    memcpy(res + sizeof(*dinfo), head, 4*sizeof(char));
-    res += sizeof(*dinfo) + 4*sizeof(char);
-    memcpy(res + nbytes, tail, 4*sizeof(char));
+    memcpy(res + sizeof(*dinfo), head, 8*sizeof(char));
+    res += sizeof(*dinfo) + 8*sizeof(char);
+    memcpy(res + nbytes, tail, 8*sizeof(char));
     return res;
 }
 
@@ -159,7 +159,7 @@ void *xcalloc_d(size_t nmemb, size_t siz
     struct dmalloc_info *dinfo;
     size_t nbytes = nmemb * size;
     
-    if (!(res = (char*) calloc(1, nbytes+sizeof(*dinfo)+8*sizeof(char))))
+    if (!(res = (char*) calloc(1, nbytes+sizeof(*dinfo)+16*sizeof(char))))
 	return 0;
     dinfo = (struct dmalloc_info *) res;
     strncpy (dinfo->file, file, sizeof(dinfo->file)-1);
@@ -173,9 +173,9 @@ void *xcalloc_d(size_t nmemb, size_t siz
 	dinfo->next->prev = dinfo;
     dmalloc_list = dinfo;
     
-    memcpy(res + sizeof(*dinfo), head, 4*sizeof(char));
-    res += sizeof(*dinfo) + 4*sizeof(char);
-    memcpy(res + nbytes, tail, 4*sizeof(char));
+    memcpy(res + sizeof(*dinfo), head, 8*sizeof(char));
+    res += sizeof(*dinfo) + 8*sizeof(char);
+    memcpy(res + nbytes, tail, 8*sizeof(char));
     return res;
 }
 
@@ -188,7 +188,7 @@ void xmalloc_trav_d(const char *file, in
     while (dinfo)
     {
 	yaz_log (LOG_MALLOC, " %20s:%d p=%p size=%d", dinfo->file, dinfo->line,
-	      ((char*) dinfo)+sizeof(*dinfo)+4*sizeof(char), dinfo->len);
+	      ((char*) dinfo)+sizeof(*dinfo)+8*sizeof(char), dinfo->len);
 	size += dinfo->len;
 	dinfo = dinfo->next;
     }
