*** nfs/syscalls.c.orig	Thu Jan 16 20:55:59 1997
--- nfs/syscalls.c	Tue Jul  1 13:18:52 1997
***************
*** 21,27 ****
  #ifdef NeXT
  #  include <nfs/nfs_mount.h>
  int	syscall_mount(char *dir, void *root_fh, int sock_fd,
! 												struct sockaddr_in *socket)
  {
  struct nfs_args		nfs_args;
  
--- 21,27 ----
  #ifdef NeXT
  #  include <nfs/nfs_mount.h>
  int	syscall_mount(char *dir, void *root_fh, int sock_fd,
! 												struct sockaddr_in *socket, char* mntfrom)
  {
  struct nfs_args		nfs_args;
  
***************
*** 39,50 ****
  	nfs_args.netname	= "net";
  	return mount(MOUNT_NFS, dir, 0, (caddr_t)&nfs_args);
  }
  #endif
  /* ------------------------------------------------------------------------- */
  #ifdef linux
  #  include <linux/nfs_mount.h>
  int	syscall_mount(char *dir, void *root_fh, int sock_fd,
! 												struct sockaddr_in *sockaddr)
  {
  struct nfs_mount_data	nfs_args;
  int						ksock, kport;
--- 39,139 ----
  	nfs_args.netname	= "net";
  	return mount(MOUNT_NFS, dir, 0, (caddr_t)&nfs_args);
  }
+ 
+ int syscall_unmount(char* dir)
+ {
+ 	unmount(dir);
+ }
+ #endif
+ /* ------------------------------------------------------------------------- */
+ #ifdef BSD4_4
+ #define NFSX_V2FH 32
+ #ifdef BSD4_4_LITE2
+ #include <nfs/rpcv2.h>
+ #include <nfs/nfs.h>
+ #endif
+ int	syscall_mount(char *dir, void *root_fh, int sock_fd,
+ 												struct sockaddr_in *socket, char* mntfrom)
+ {
+ struct nfs_args		nfs_args;
+ #ifdef __FreeBSD__
+ #ifdef _NEW_VFSCONF
+ struct vfsconf vfc;
+ int error;
+ #else
+ struct vfsconf* vfc;
+ #endif
+ #endif
+ 
+ 	bzero(&nfs_args, sizeof(nfs_args));
+ #ifdef BSD4_4_LITE2
+ 	nfs_args.version	= NFS_ARGSVERSION;
+ #endif
+ 	nfs_args.wsize		= 8192;
+ 	nfs_args.rsize		= 8192;
+ 	nfs_args.retrans	= 0;
+ 	nfs_args.timeo		= 100;	/* 10s timeout */
+ 	nfs_args.addr		= (struct sockaddr*)socket;
+ 	nfs_args.addrlen	= sizeof(*socket);
+ 	nfs_args.sotype		= SOCK_DGRAM;
+ 	nfs_args.flags		= NFSMNT_SOFT |
+ 							NFSMNT_RETRANS | NFSMNT_TIMEO |
+ 							NFSMNT_WSIZE | NFSMNT_RSIZE;
+ 	nfs_args.fh			= (char *)root_fh;
+ 	nfs_args.fhsize		= NFSX_V2FH;
+ 	nfs_args.hostname	= mntfrom;
+ #ifdef BSD4_4_LITE2
+ #define NFSNAME "nfs"
+ #else
+ #define NFSNAME MOUNT_NFS
+ #endif
+ #ifdef __FreeBSD__
+ #ifdef _NEW_VFSCONF
+ #define GETVFSBYNAME	error = getvfsbyname("nfs", &vfc)
+ #define VFCERROR	error
+ #define VFCNFSNAME	vfc.vfc_name
+ #else
+ #define GETVFSBYNAME	vfc = getvfsbyname("nfs")
+ #define VFCERROR	!vfc
+ #define VFCNFSNAME	vfc->vfc_index
+ #endif
+ 	GETVFSBYNAME;
+ 	if (VFCERROR && vfsisloadable("nfs")) {
+ 		if(vfsload("nfs"))
+ 			return -1;
+ 		endvfsent();	/* clear cache */
+ 		GETVFSBYNAME;
+ 	}
+ 	if (VFCERROR)
+ 		return -1;
+ 	return mount(VFCNFSNAME, dir, 0, &nfs_args);
+ #else
+ 	return mount(NFSNAME, dir, 0, &nfs_args);
+ #endif
+ }
+ 
+ int syscall_unmount(char* dir)
+ {
+ struct statfs* mntbuf;
+ int count, i;
+ 
+ 	if ((count = getmntinfo(&mntbuf, MNT_NOWAIT)) < 0)
+ 		return -1;
+ 	for (i=0; i<count; i++) {
+ 		if (strcmp(mntbuf[i].f_mntonname, dir) == 0) {
+ 			return unmount(dir,0);
+ 		}
+ 	}
+ 	errno = ENOENT;
+ 	return -1;
+ }
+ 
  #endif
  /* ------------------------------------------------------------------------- */
  #ifdef linux
  #  include <linux/nfs_mount.h>
  int	syscall_mount(char *dir, void *root_fh, int sock_fd,
! 												struct sockaddr_in *sockaddr, char* mntfrom)
  {
  struct nfs_mount_data	nfs_args;
  int						ksock, kport;
***************
*** 92,97 ****
--- 181,190 ----
  		exit(1);
  	}
  	return mount("rumba:/", dir, "nfs", 0xc0ed0000, &nfs_args);
+ }
+ int syscall_unount(char* dir)
+ {
+ 	umount(dir);
  }
  #endif
  /* ------------------------------------------------------------------------- */
