$NetBSD: patch-dc,v 1.1.1.1 1999/10/08 04:34:43 dbj Exp $

--- netbsd-1.4/ppp_tty.c.orig2	Sat Sep 18 11:06:15 1999
+++ netbsd-1.4/ppp_tty.c	Sat Sep 18 11:09:46 1999
@@ -123,9 +123,13 @@
 int	pppinput __P((int c, struct tty *tp));
 int	pppstart __P((struct tty *tp));
 
+#ifdef TIOCRCVFRAME
 static void	ppprcvframe __P((struct ppp_softc *sc, struct mbuf *m));
+#endif
 static u_int16_t pppfcs __P((u_int16_t fcs, u_char *cp, int len));
+#ifdef TIOCXMTFRAME
 static void	pppsyncstart __P((struct ppp_softc *sc));
+#endif
 static void	pppasyncstart __P((struct ppp_softc *));
 static void	pppasyncctlp __P((struct ppp_softc *));
 static void	pppasyncrelinq __P((struct ppp_softc *));
@@ -202,7 +206,11 @@
 
 #if NBPFILTER > 0
     /* Switch DLT to PPP-over-serial. */
+#ifdef DLT_PPP_SERIAL
     bpf_change_type(&sc->sc_bpf, DLT_PPP_SERIAL, PPP_HDRLEN);
+#else
+    bpf_change_type(&sc->sc_bpf, DLT_PPP, PPP_HDRLEN);
+#endif
 #endif
 
     sc->sc_ilen = 0;
@@ -414,9 +422,11 @@
 
     error = 0;
     switch (cmd) {
+#ifdef TIOCRCVFRAME
     case TIOCRCVFRAME:
     	ppprcvframe(sc,*((struct mbuf **)data));
 	break;
+#endif
 	
     case PPPIOCSASYNCMAP:
 	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@@ -462,6 +472,7 @@
     return error;
 }
 
+#ifdef TIOCRCVFRAME
 /* receive a complete ppp frame from device in synchronous
  * hdlc mode. caller gives up ownership of mbuf
  */
@@ -570,6 +581,7 @@
 	m_freem(m);
 	splx(s);
 }
+#endif
 
 /*
  * FCS lookup table as calculated by genfcstab.
@@ -623,6 +635,7 @@
     return (fcs);
 }
 
+#ifdef TIOCXMTFRAME
 /* This gets called at splsoftnet from pppasyncstart at various times
  * when there is data ready to be sent.
  */
@@ -657,6 +670,7 @@
 		sc->sc_stats.ppp_obytes += len;
 	}
 }
+#endif
 
 /*
  * This gets called at splsoftnet from if_ppp.c at various times
@@ -674,10 +688,12 @@
     struct mbuf *m2;
     int s;
 
+#ifdef TIOCXMTFRAME
     if (sc->sc_flags & SC_SYNC){
 	pppsyncstart(sc);
 	return;
     }
+#endif
     
     idle = 0;
     while (CCOUNT(&tp->t_outq) < PPP_HIWAT) {
