$NetBSD: patch-ac,v 1.1.1.1 2005/03/07 15:59:08 bouyer Exp $

--- python/xen/lowlevel/xu/xu.c.orig	2005-01-12 13:22:21.000000000 +0100
+++ python/xen/lowlevel/xu/xu.c	2005-02-05 20:22:08.000000000 +0100
@@ -15,7 +15,6 @@
 #include <sys/socket.h>
 #include <sys/mman.h>
 #include <sys/poll.h>
-#include <sys/sysmacros.h>
 #include <netinet/in.h>
 #include <fcntl.h>
 #include <unistd.h>
@@ -25,7 +24,7 @@
 
 #include <xen/xen.h>
 #include <xen/io/domain_controller.h>
-#include <xen/linux/privcmd.h>
+#include <xen/NetBSD/xenio.h>
 
 #define XENPKG "xen.lowlevel.xu"
 
@@ -35,6 +34,9 @@
 #endif
 
 /* NB. The following should be kept in sync with the kernel's evtchn driver. */
+#ifdef __NetBSD__
+#define EVTCHN_DEV_NAME  "/dev/xenevt"
+#else
 #define EVTCHN_DEV_NAME  "/dev/xen/evtchn"
 #define EVTCHN_DEV_MAJOR 10
 #define EVTCHN_DEV_MINOR 201
@@ -45,6 +47,7 @@
 #define EVTCHN_BIND   _IO('E', 2)
 /* EVTCHN_UNBIND: Unbind from the specified event-channel port. */
 #define EVTCHN_UNBIND _IO('E', 3)
+#endif
 
 /* Size of a machine page frame. */
 #define PAGE_SIZE 4096
@@ -130,7 +133,11 @@
     if ( !PyArg_ParseTuple(args, "i", &idx) )
         return NULL;
 
+#ifdef __NetBSD__
+    if ( ioctl(xun->evtchn_fd, EVTCHN_BIND, &idx) != 0 )
+#else
     if ( ioctl(xun->evtchn_fd, EVTCHN_BIND, idx) != 0 )
+#endif
         return PyErr_SetFromErrno(PyExc_IOError);
 
     Py_INCREF(Py_None);
@@ -145,7 +152,11 @@
     if ( !PyArg_ParseTuple(args, "i", &idx) )
         return NULL;
 
+#ifdef __NetBSD__
+    if ( ioctl(xun->evtchn_fd, EVTCHN_UNBIND, &idx) != 0 )
+#else
     if ( ioctl(xun->evtchn_fd, EVTCHN_UNBIND, idx) != 0 )
+#endif
         return PyErr_SetFromErrno(PyExc_IOError);
 
     Py_INCREF(Py_None);
@@ -192,13 +203,16 @@
 static PyObject *xu_notifier_new(PyObject *self, PyObject *args)
 {
     xu_notifier_object *xun;
+#ifndef __NetBSD__
     struct stat st;
+#endif
 
     if ( !PyArg_ParseTuple(args, "") )
         return NULL;
 
     xun = PyObject_New(xu_notifier_object, &xu_notifier_type);
 
+#ifndef __NetBSD__
     /* Make sure any existing device file links to correct device. */
     if ( (lstat(EVTCHN_DEV_NAME, &st) != 0) ||
          !S_ISCHR(st.st_mode) ||
@@ -206,14 +220,17 @@
         (void)unlink(EVTCHN_DEV_NAME);
 
  reopen:
+#endif
     xun->evtchn_fd = open(EVTCHN_DEV_NAME, O_NONBLOCK|O_RDWR);
     if ( xun->evtchn_fd == -1 )
     {
+#ifndef __NetBSD__
         if ( (errno == ENOENT) &&
              ((mkdir("/dev/xen", 0755) == 0) || (errno == EEXIST)) &&
              (mknod(EVTCHN_DEV_NAME, S_IFCHR|0600, 
                     makedev(EVTCHN_DEV_MAJOR,EVTCHN_DEV_MINOR)) == 0) )
             goto reopen;
+#endif
         PyObject_Del((PyObject *)xun);
         return PyErr_SetFromErrno(PyExc_IOError);
     }
@@ -1083,7 +1100,8 @@
          * The control-interface event channel for DOM0 is already set up.
          * We use an ioctl to discover the port at our end of the channel.
          */
-        port1 = ioctl(xup->xc_handle, IOCTL_PRIVCMD_INITDOMAIN_EVTCHN, NULL);
+        (void)ioctl(xup->xc_handle, IOCTL_PRIVCMD_INITDOMAIN_EVTCHN, NULL);
+	port1 = errno;
         port2 = -1; /* We don't need the remote end of the DOM0 link. */
         if ( port1 < 0 )
         {
