$NetBSD: patch-aa,v 1.1.1.1 2000/07/13 21:39:13 bjh21 Exp $
Index: gcc/config/arm/aout.h
===================================================================
RCS file: /cvsroot/gnusrc/gnu/dist/gcc/config/arm/aout.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -r1.4 -r1.5
--- aout.h	1998/08/16 20:41:04	1.4
+++ aout.h	2000/07/02 12:31:23	1.5
@@ -1,5 +1,5 @@
 /* Definitions of target machine for GNU compiler, for ARM with a.out
-   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
    Contributed by Richard Earnshaw (rearnsha@armltd.co.uk).
    
 This file is part of GNU CC.
@@ -24,6 +24,7 @@
 #endif
 
 /* The text to go at the start of the assembler file */
+#ifndef ASM_FILE_START
 #define ASM_FILE_START(STREAM)						    \
 {									    \
   fprintf (STREAM,"%srfp\t.req\t%sr9\n", REGISTER_PREFIX, REGISTER_PREFIX); \
@@ -34,22 +35,35 @@
   fprintf (STREAM,"%slr\t.req\t%sr14\n", REGISTER_PREFIX, REGISTER_PREFIX); \
   fprintf (STREAM,"%spc\t.req\t%sr15\n", REGISTER_PREFIX, REGISTER_PREFIX); \
 }
+#endif
 
-#define ASM_APP_ON  ""
-#define ASM_APP_OFF  ""
+#define ASM_APP_ON  		""
+#define ASM_APP_OFF  		""
 
 /* Switch to the text or data segment.  */
-#define TEXT_SECTION_ASM_OP  ".text"
-#define DATA_SECTION_ASM_OP  ".data"
-#define BSS_SECTION_ASM_OP   ".bss"
-
-#define REGISTER_PREFIX ""
-#define USER_LABEL_PREFIX "_"
-#define LOCAL_LABEL_PREFIX ""
+#define TEXT_SECTION_ASM_OP  	".text"
+#define DATA_SECTION_ASM_OP  	".data"
+#define BSS_SECTION_ASM_OP   	".bss"
+
+/* Note: If USER_LABEL_PREFIX or LOCAL_LABEL_PREFIX are changed,
+   make sure that this change is reflected in the function
+   coff_arm_is_local_label_name() in bfd/coff-arm.c  */
+#ifndef REGISTER_PREFIX
+#define REGISTER_PREFIX 	""
+#endif
+
+#ifndef USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX 	"_"
+#endif
+
+#ifndef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX 	""
+#endif
 
+
 /* The assembler's names for the registers.  */
 #ifndef REGISTER_NAMES
-#define REGISTER_NAMES  \
+#define REGISTER_NAMES  			   \
 {				                   \
   "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",  \
   "r8", "r9", "sl", "fp", "ip", "sp", "lr", "pc",  \
@@ -93,7 +107,9 @@
 
 /* Generate DBX debugging information.  riscix.h will undefine this because
    the native assembler does not support stabs. */
+#ifndef DBX_DEBUGGING_INFO
 #define DBX_DEBUGGING_INFO  1
+#endif
 
 /* Acorn dbx moans about continuation chars, so don't use any.  */
 #ifndef DBX_CONTIN_LENGTH
@@ -104,32 +120,45 @@
    ``desc'' field is set to compiler version number >= 315 (sic).  */
 #define DBX_OUTPUT_MAIN_SOURCE_FILENAME(STREAM,NAME) 			\
 do {									\
-  fprintf (STREAM, ".stabs \"%s\",%d,0,315,%s\n", (NAME), N_SO,		\
-	   &ltext_label_name[1]);					\
+  fprintf (STREAM, ".stabs ");						\
+  output_quoted_string (STREAM, NAME);					\
+  fprintf (STREAM, ",%d,0,315,%s\n", N_SO, &ltext_label_name[1]);	\
   text_section ();							\
   ASM_OUTPUT_INTERNAL_LABEL (STREAM, "Ltext", 0);			\
 } while (0)
   
 /* Output a function label definition.  */
-#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL) \
-    ASM_OUTPUT_LABEL(STREAM, NAME)
+#ifndef ASM_DECLARE_FUNCTION_NAME
+#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL)	\
+{							\
+  if (TARGET_POKE_FUNCTION_NAME)			\
+    arm_poke_function_name ((STREAM), (NAME));		\
+  ASM_OUTPUT_LABEL (STREAM, NAME);			\
+}
+#endif
 
+#ifndef ASM_OUTPUT_LABEL
 #define ASM_OUTPUT_LABEL(STREAM,NAME)	\
 do {					\
   assemble_name (STREAM,NAME);		\
   fputs (":\n", STREAM);		\
 } while (0)
-
+#endif
+     
 /* Output a globalising directive for a label.  */
+#ifndef ASM_GLOBALIZE_LABEL
 #define ASM_GLOBALIZE_LABEL(STREAM,NAME)  \
   (fprintf (STREAM, "\t.global\t"),	  \
    assemble_name (STREAM, NAME),	  \
-   fputc ('\n',STREAM))                   \
+   fputc ('\n',STREAM))                   
+#endif
 
 /* Make an internal label into a string.  */
+#ifndef ASM_GENERATE_INTERNAL_LABEL
 #define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)  \
-  sprintf (STRING, "*%s%s%d", LOCAL_LABEL_PREFIX, PREFIX, NUM)
-
+  sprintf (STRING, "*%s%s%u", LOCAL_LABEL_PREFIX, PREFIX, (unsigned int)(NUM))
+#endif
+     
 /* Nothing special is done about jump tables */
 /* #define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE)   */
 /* #define ASM_OUTPUT_CASE_END(STREAM,NUM,TABLE)	    */
@@ -196,17 +225,18 @@
    output_addr_const (STREAM, (EXP)),  \
    fputc ('\n', STREAM))
 
-#define ASM_OUTPUT_BYTE(STREAM, VALUE)  \
+#define ASM_OUTPUT_BYTE(STREAM, VALUE)  	\
   fprintf (STREAM, "\t.byte\t%d\n", VALUE)
 
 #define ASM_OUTPUT_ASCII(STREAM, PTR, LEN)  \
   output_ascii_pseudo_op ((STREAM), (unsigned char *)(PTR), (LEN))
 
 /* Output a gap.  In fact we fill it with nulls.  */
-#define ASM_OUTPUT_SKIP(STREAM, NBYTES)  \
+#define ASM_OUTPUT_SKIP(STREAM, NBYTES) 	\
    fprintf (STREAM, "\t.space\t%d\n", NBYTES)
 
 /* Align output to a power of two.  Horrible /bin/as.  */
+#ifndef ASM_OUTPUT_ALIGN  
 #define ASM_OUTPUT_ALIGN(STREAM, POWER)  \
   do                                                           \
     {                                                          \
@@ -216,16 +246,23 @@
 	fprintf (STREAM, "\t.even\n");                         \
       else if (amount != 1)                                    \
 	fprintf (STREAM, "\t.align\t%d\n", amount - 4);        \
-    } while (0)
+    }							       \
+  while (0)
+#endif
 
 /* Output a common block */
+#ifndef ASM_OUTPUT_COMMON
 #define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)  		\
   (fprintf (STREAM, "\t.comm\t"), 		     			\
    assemble_name ((STREAM), (NAME)),		     			\
-   fprintf(STREAM, ", %d\t%s %d\n", ROUNDED, ASM_COMMENT_START, SIZE))
-
+   fprintf (STREAM, ", %d\t%s %d\n", ROUNDED, ASM_COMMENT_START, SIZE))
+#endif
+     
 /* Output a local common block.  /bin/as can't do this, so hack a
-   `.space' into the bss segment.  Note that this is *bad* practice.  */
+   `.space' into the bss segment.  Note that this is *bad* practice,
+   which is guaranteed NOT to work since it doesn't define STATIC
+   COMMON space but merely STATIC BSS space.  */
+#ifndef ASM_OUTPUT_ALIGNED_LOCAL
 #define ASM_OUTPUT_ALIGNED_LOCAL(STREAM,NAME,SIZE,ALIGN)		\
   do {									\
     bss_section ();							\
@@ -233,27 +270,32 @@
     ASM_OUTPUT_LABEL (STREAM, NAME);					\
     fprintf (STREAM, "\t.space\t%d\n", SIZE);				\
   } while (0)
-
+#endif
+     
 /* Output a zero-initialized block.  */
+#ifndef ASM_OUTPUT_ALIGNED_BSS
 #define ASM_OUTPUT_ALIGNED_BSS(STREAM,DECL,NAME,SIZE,ALIGN) \
-  asm_output_aligned_bss(STREAM, DECL, NAME, SIZE, ALIGN)
-
+  asm_output_aligned_bss (STREAM, DECL, NAME, SIZE, ALIGN)
+#endif
+     
 /* Output a source line for the debugger.  */
 /* #define ASM_OUTPUT_SOURCE_LINE(STREAM,LINE) */
 
 /* Output a #ident directive.  */
+#ifndef ASM_OUTPUT_IDENT
 #define ASM_OUTPUT_IDENT(STREAM,STRING)  \
-  fprintf (STREAM,"- - - ident %s\n",STRING)
-
+  fprintf (STREAM, "%s - - - ident %s\n", ASM_COMMENT_START, STRING)
+#endif
+     
 /* The assembler's parentheses characters.  */
-#define ASM_OPEN_PAREN "("
-#define ASM_CLOSE_PAREN ")"
+#define ASM_OPEN_PAREN 		"("
+#define ASM_CLOSE_PAREN 	")"
 
 #ifndef ASM_COMMENT_START
-#define ASM_COMMENT_START "@"
+#define ASM_COMMENT_START 	"@"
 #endif
 
 /* This works for GAS and some other assemblers.  */
-#define SET_ASM_OP	".set"
+#define SET_ASM_OP		".set"
 
 #include "arm/arm.h"
Index: gcc/config/arm/arm.h
===================================================================
RCS file: /cvsroot/gnusrc/gnu/dist/gcc/config/arm/arm.h,v
retrieving revision 1.9
retrieving revision 1.10
diff -u -r1.9 -r1.10
--- arm.h	1998/12/03 16:05:47	1.9
+++ arm.h	2000/07/02 12:31:23	1.10
@@ -565,7 +565,9 @@
 /* This is for compatibility with ARMCC.  ARM SDT Reference Manual
    (ARM DUI 0020D) page 2-20 says "Structures are aligned on word
    boundaries".  */
+#ifndef STRUCTURE_SIZE_BOUNDARY
 #define STRUCTURE_SIZE_BOUNDARY 32
+#endif
 
 /* Non-zero if move instructions will actually fail to work
    when given unaligned data.  */
@@ -1825,6 +1827,7 @@
   goto JUMPTO
 
 /* Output an internal label definition.  */
+#ifndef ASM_OUTPUT_INTERNAL_LABEL
 #define ASM_OUTPUT_INTERNAL_LABEL(STREAM, PREFIX, NUM)  	\
   do                                    	      	   	\
     {						      	   	\
@@ -1841,6 +1844,7 @@
 	ASM_GENERATE_INTERNAL_LABEL (s, (PREFIX), (NUM));   	\
 	ASM_OUTPUT_LABEL (STREAM, s);		                \
     } while (0)
+#endif
 
 /* Output a push or a pop instruction (only used when profiling).  */
 #define ASM_OUTPUT_REG_PUSH(STREAM,REGNO) \
Index: gcc/config/arm/elf.h
===================================================================
RCS file: elf.h
diff -N elf.h
--- /dev/null	Sun Jul  2 03:46:48 2000
+++ gcc/config/arm/elf.h	Sun Jul  2 07:04:41 2000
@@ -0,0 +1,391 @@
+/* Definitions of target machine for GNU compiler,
+   for ARM with ELF obj format.
+   Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+   Contributed by Philip Blundell <philb@gnu.org> and
+   Catherine Moore <clm@cygnus.com>
+   
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+
+#define OBJECT_FORMAT_ELF
+
+#ifndef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX "."
+#endif
+
+#ifndef USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX ""
+#endif
+
+#ifndef CPP_PREDEFINES
+#define CPP_PREDEFINES "-Darm -Darm_elf -Acpu(arm) -Amachine(arm) -D__ELF__"
+#endif
+
+/* The following macro defines the format used to output the second
+   operand of the .type assembler directive.  Different svr4 assemblers
+   expect various different forms for this operand.  The one given here
+   is just a default.  You may need to override it in your machine-
+   specific tm.h file (depending upon the particulars of your assembler).  */
+#define TYPE_OPERAND_FMT	"%s"
+
+/* Write the extra assembler code needed to declare a function's result.
+   Most svr4 assemblers don't require any special declaration of the
+   result value, but there are exceptions.  */
+#ifndef ASM_DECLARE_RESULT
+#define ASM_DECLARE_RESULT(FILE, RESULT)
+#endif
+
+/* These macros generate the special .type and .size directives which
+   are used to set the corresponding fields of the linker symbol table
+   entries in an ELF object file under SVR4.  These macros also output
+   the starting labels for the relevant functions/objects.  */
+#define TYPE_ASM_OP     ".type"
+#define SIZE_ASM_OP     ".size"
+
+/* Write the extra assembler code needed to declare a function properly.
+   Some svr4 assemblers need to also have something extra said about the
+   function's return value.  We allow for that here.  */
+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)	\
+  do							\
+    {							\
+      if (TARGET_POKE_FUNCTION_NAME)			\
+        arm_poke_function_name (FILE, NAME);		\
+      fprintf (FILE, "\t%s\t ", TYPE_ASM_OP);		\
+      assemble_name (FILE, NAME);			\
+      putc (',', FILE);					\
+      fprintf (FILE, TYPE_OPERAND_FMT, "function");	\
+      putc ('\n', FILE);				\
+      ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));	\
+      ASM_OUTPUT_LABEL(FILE, NAME);			\
+    }							\
+  while (0)
+
+/* Write the extra assembler code needed to declare an object properly.  */
+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)			\
+  do {									\
+    fprintf (FILE, "\t%s\t ", TYPE_ASM_OP);				\
+    assemble_name (FILE, NAME);						\
+    putc (',', FILE);							\
+    fprintf (FILE, TYPE_OPERAND_FMT, "object");				\
+    putc ('\n', FILE);							\
+    size_directive_output = 0;						\
+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))		\
+      {									\
+	size_directive_output = 1;					\
+	fprintf (FILE, "\t%s\t ", SIZE_ASM_OP);				\
+	assemble_name (FILE, NAME);					\
+	putc (',', FILE);						\
+	fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,				\
+		 int_size_in_bytes (TREE_TYPE (DECL)));			\
+	fputc ('\n', FILE);						\
+      }									\
+    ASM_OUTPUT_LABEL(FILE, NAME);					\
+  } while (0)
+
+/* Output the size directive for a decl in rest_of_decl_compilation
+   in the case where we did not do so before the initializer.
+   Once we find the error_mark_node, we know that the value of
+   size_directive_output was set
+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */
+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)	 \
+do {									 \
+     char * name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);			 \
+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)		 \
+         && ! AT_END && TOP_LEVEL					 \
+	 && DECL_INITIAL (DECL) == error_mark_node			 \
+	 && !size_directive_output)					 \
+       {								 \
+	 size_directive_output = 1;					 \
+	 fprintf (FILE, "\t%s\t ", SIZE_ASM_OP);			 \
+	 assemble_name (FILE, name);					 \
+	 putc (',', FILE);						 \
+	 fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,			 \
+		  int_size_in_bytes (TREE_TYPE (DECL))); 		 \
+	fputc ('\n', FILE);						 \
+       }								 \
+   } while (0)
+
+/* This is how to declare the size of a function.  */
+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)			\
+  do {									\
+    if (!flag_inhibit_size_directive)					\
+      {									\
+        char label[256];						\
+	static int labelno;						\
+	labelno ++;							\
+	ASM_GENERATE_INTERNAL_LABEL (label, "Lfe", labelno);		\
+	ASM_OUTPUT_INTERNAL_LABEL (FILE, "Lfe", labelno);		\
+	fprintf (FILE, "\t%s\t ", SIZE_ASM_OP);				\
+	assemble_name (FILE, (FNAME));					\
+        fprintf (FILE, ",");						\
+	assemble_name (FILE, label);					\
+        fprintf (FILE, "-");						\
+	assemble_name (FILE, (FNAME));					\
+	putc ('\n', FILE);						\
+      }									\
+  } while (0)
+
+/* Define this macro if jump tables (for `tablejump' insns) should be
+   output in the text section, along with the assembler instructions.
+   Otherwise, the readonly data section is used.  */
+#define JUMP_TABLES_IN_TEXT_SECTION 1
+
+#ifndef ASM_SPEC
+#define ASM_SPEC "%{mbig-endian:-EB} %{mcpu=*:-m%*} %{march=*:-m%*} \
+ %{mapcs-*:-mapcs-%*} %{mthumb-interwork:-mthumb-interwork} %{mapcs-float:mfloat}"
+#endif
+
+#ifndef LINK_SPEC
+#define LINK_SPEC "%{mbig-endian:-EB} -X"
+#endif
+  
+/* Run-time Target Specification.  */
+#ifndef TARGET_VERSION
+#define TARGET_VERSION fputs (" (ARM/elf)", stderr)
+#endif
+
+#ifndef TARGET_DEFAULT
+#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_32)
+#endif
+
+#ifndef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS { "mlittle-endian", "msoft-float", "mapcs-32", "mno-thumb-interwork" }
+#endif
+
+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS
+   is a valid machine specific attribute for DECL.
+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */
+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \
+arm_valid_machine_decl_attribute (DECL, IDENTIFIER, ARGS)
+
+
+/* A C statement to output assembler commands which will identify the
+   object file as having been compiled with GNU CC (or another GNU
+   compiler).  */
+/* Define this to NULL so we don't get anything.
+   We have ASM_IDENTIFY_LANGUAGE.
+   Also, when using stabs, gcc2_compiled must be a stabs entry, not an
+   ordinary symbol, or gdb won't see it.  The stabs entry must be
+   before the N_SO in order for gdb to find it.  */
+#ifndef ASM_IDENTIFY_GCC
+#define ASM_IDENTIFY_GCC(STREAM) 				\
+     fprintf (STREAM, "%sgcc2_compiled.:\n", LOCAL_LABEL_PREFIX )
+#endif
+
+/* This outputs a lot of .req's to define alias for various registers.
+   Let's try to avoid this.  */
+#ifndef ASM_FILE_START
+#define ASM_FILE_START(STREAM) \
+do {								\
+  extern char * version_string;					\
+  fprintf (STREAM, "%s Generated by gcc %s for ARM/elf\n",	\
+	   ASM_COMMENT_START, version_string);			\
+  output_file_directive ((STREAM), main_input_filename);	\
+} while (0)
+#endif
+     
+/* Output an internal label definition.  */
+#ifndef ASM_OUTPUT_INTERNAL_LABEL
+#define ASM_OUTPUT_INTERNAL_LABEL(STREAM, PREFIX, NUM)  	\
+  do                                    	      	   	\
+    {						      	   	\
+      char * s = (char *) alloca (40 + strlen (PREFIX));	\
+      extern int arm_target_label, arm_ccfsm_state;	   	\
+      extern rtx arm_target_insn;				\
+						           	\
+      if (arm_ccfsm_state == 3 && arm_target_label == (NUM)   	\
+	&& !strcmp (PREFIX, "L"))				\
+	{							\
+	  arm_ccfsm_state = 0;				        \
+	  arm_target_insn = NULL;				\
+	}							\
+	ASM_GENERATE_INTERNAL_LABEL (s, (PREFIX), (NUM));   	\
+	ASM_OUTPUT_LABEL (STREAM, s);	                	\
+    } while (0)
+#endif
+
+/* Support the ctors/dtors and other sections.  */
+
+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.
+
+   Note that we want to give these sections the SHF_WRITE attribute
+   because these sections will actually contain data (i.e. tables of
+   addresses of functions in the current root executable or shared library
+   file) and, in the case of a shared library, the relocatable addresses
+   will have to be properly resolved/relocated (and then written into) by
+   the dynamic linker when it actually attaches the given shared library
+   to the executing process.  (Note that on SVR4, you may wish to use the
+   `-z text' option to the ELF linker, when building a shared library, as
+   an additional check that you are doing everything right.  But if you do
+   use the `-z text' option when building a shared library, you will get
+   errors unless the .ctors and .dtors sections are marked as writable
+   via the SHF_WRITE attribute.)  */
+#ifndef CTORS_SECTION_ASM_OP
+#define CTORS_SECTION_ASM_OP	"\t.section\t.ctors,\"aw\""
+#endif
+     
+#ifndef DTORS_SECTION_ASM_OP
+#define DTORS_SECTION_ASM_OP	"\t.section\t.dtors,\"aw\""
+#endif
+
+/* A list of other sections which the compiler might be "in" at any
+   given time.  */
+#ifndef SUBTARGET_EXTRA_SECTIONS
+#define SUBTARGET_EXTRA_SECTIONS
+#endif
+
+#ifndef EXTRA_SECTIONS
+#define EXTRA_SECTIONS SUBTARGET_EXTRA_SECTIONS in_ctors, in_dtors
+#endif
+
+/* A list of extra section function definitions.  */
+#ifndef SUBTARGET_EXTRA_SECTION_FUNCTIONS
+#define SUBTARGET_EXTRA_SECTION_FUNCTIONS
+#endif
+
+#ifndef EXTRA_SECTION_FUNCTIONS
+#define EXTRA_SECTION_FUNCTIONS 		\
+  SUBTARGET_EXTRA_SECTION_FUNCTIONS		\
+  CTORS_SECTION_FUNCTION			\
+  DTORS_SECTION_FUNCTION			
+#endif
+
+#ifndef CTORS_SECTION_FUNCTION
+#define CTORS_SECTION_FUNCTION 						\
+void									\
+ctors_section ()							\
+{									\
+  if (in_section != in_ctors)						\
+    {									\
+      fprintf (asm_out_file, "%s\n", CTORS_SECTION_ASM_OP);		\
+      in_section = in_ctors;						\
+    }									\
+}
+#endif
+
+#ifndef DTORS_SECTION_FUNCTION
+#define DTORS_SECTION_FUNCTION 						\
+void									\
+dtors_section ()							\
+{									\
+  if (in_section != in_dtors)						\
+    {									\
+      fprintf (asm_out_file, "%s\n", DTORS_SECTION_ASM_OP);		\
+      in_section = in_dtors;						\
+    }									\
+}
+#endif
+
+/* Switch into a generic section.
+   This is currently only used to support section attributes.  */
+#ifndef ASM_OUTPUT_SECTION_NAME
+#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC)		\
+do {									\
+  static struct section_info						\
+    {									\
+      struct section_info *next;				        \
+      char *name;						        \
+      enum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;		\
+    } *sections;							\
+  struct section_info *s;						\
+  char *mode;								\
+  enum sect_enum type;							\
+									\
+  for (s = sections; s; s = s->next)					\
+    if (!strcmp (NAME, s->name))					\
+      break;								\
+									\
+  if (DECL && TREE_CODE (DECL) == FUNCTION_DECL)			\
+    type = SECT_EXEC, mode = "ax";					\
+  else if (DECL && DECL_READONLY_SECTION (DECL, RELOC))			\
+    type = SECT_RO, mode = "a";						\
+  else									\
+    type = SECT_RW, mode = "aw";					\
+									\
+  if (s == 0)								\
+    {									\
+      s = (struct section_info *) xmalloc (sizeof (struct section_info));  \
+      s->name = xmalloc ((strlen (NAME) + 1) * sizeof (*NAME));		\
+      strcpy (s->name, NAME);						\
+      s->type = type;							\
+      s->next = sections;						\
+      sections = s;							\
+      fprintf (FILE, ".section\t%s,\"%s\",@progbits\n", NAME, mode);	\
+    }									\
+  else									\
+    {									\
+      if (DECL && s->type != type)					\
+	error_with_decl (DECL, "%s causes a section type conflict");	\
+									\
+      fprintf (FILE, ".section\t%s\n", NAME);				\
+    }									\
+} while (0)
+#endif
+
+/* Support the ctors/dtors sections for g++.  */
+#ifndef INT_ASM_OP
+#define INT_ASM_OP 	".word"
+#endif
+
+/* A C statement (sans semicolon) to output an element in the table of
+   global constructors.  */
+#ifndef ASM_OUTPUT_CONSTRUCTOR
+#define ASM_OUTPUT_CONSTRUCTOR(STREAM,NAME) \
+do {						\
+  ctors_section ();				\
+  fprintf (STREAM, "\t%s\t ", INT_ASM_OP);	\
+  assemble_name (STREAM, NAME);			\
+  fprintf (STREAM, "\n");			\
+} while (0)
+#endif
+     
+/* A C statement (sans semicolon) to output an element in the table of
+   global destructors.  */
+#ifndef ASM_OUTPUT_DESTRUCTOR
+#define ASM_OUTPUT_DESTRUCTOR(STREAM,NAME) \
+do {						\
+  dtors_section ();                   		\
+  fprintf (STREAM, "\t%s\t ", INT_ASM_OP);	\
+  assemble_name (STREAM, NAME);              	\
+  fprintf (STREAM, "\n");			\
+} while (0)
+#endif
+
+/* This is how we tell the assembler that a symbol is weak.  */
+
+#define ASM_WEAKEN_LABEL(FILE,NAME) \
+  do { fputs ("\t.weak\t", FILE); assemble_name (FILE, NAME); \
+       fputc ('\n', FILE); } while (0)
+
+/* For PIC code we need to explicitly specify (PLT) and (GOT) relocs.  */
+#define NEED_PLT_GOT	flag_pic
+
+/* The ELF assembler handles GOT addressing differently to NetBSD.  */
+#define GOT_PCREL	0
+
+/* Biggest alignment supported by the object file format of this
+   machine.  Use this macro to limit the alignment which can be
+   specified using the `__attribute__ ((aligned (N)))' construct.  If
+   not defined, the default value is `BIGGEST_ALIGNMENT'.  */
+#define MAX_OFILE_ALIGNMENT (32768*8)
+
+/* Align output to a power of two.  */
+#define ASM_OUTPUT_ALIGN(STREAM, POWER)  \
+   fprintf (STREAM, "\t.align\t%d\n", POWER)
+
+#include "arm/aout.h"
Index: gcc/config/arm/netbsd26.h
===================================================================
RCS file: netbsd26.h
diff -N netbsd26.h
--- /dev/null	Sun Jul  2 03:46:48 2000
+++ gcc/config/arm/netbsd26.h	Sun Jul  2 07:04:42 2000
@@ -0,0 +1,125 @@
+/* NetBSD/arm (RiscBSD) version.
+   Copyright (C) 1993, 1994, 1997, 1998 Free Software Foundation, Inc.
+   Contributed by Mark Brinicombe (amb@physig.ph.kcl.ac.uk)
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Run-time Target Specification.  */
+#define TARGET_VERSION fputs (" (ARMv2/NetBSD)", stderr);
+
+/* This is used in ASM_FILE_START.  */
+#define ARM_OS_NAME "NetBSD"
+
+/* Unsigned chars produces much better code than signed.  */
+#define DEFAULT_SIGNED_CHAR  0
+
+/*#undef ASM_DECLARE_FUNCTION_NAME*/
+
+/* ARM3 family default cpu.  */
+#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm3
+
+/* Default is to use APCS-26 mode.  */
+#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT)
+
+#include "arm/elf.h"
+
+/* This gets redefined in config/netbsd.h.  */
+#undef TARGET_MEM_FUNCTIONS
+
+#include <netbsd.h>
+
+/* Override standard NetBSD asm spec.  What do they know? */
+#undef ASM_SPEC
+/* Don't bother telling the assembler the CPU type -- assume the compiler
+   won't generate bogus code and anyone using asm() knows what they're
+   doing. */
+#define ASM_SPEC "%{mbig-endian:-EB} \
+ %{!mapcs-32:-mapcs-26} %{mapcs-32:-mapcs-32} \
+ %{mapcs-float:-mapcs-float} \
+ %{mthumb-interwork:-mthumb-interwork} \
+ %{fpic:-k} %{fPIC:-k}"
+
+/* Some defines for CPP.
+   arm26 is the NetBSD port name, so we always define arm26 and __arm26__.  */
+#undef CPP_PREDEFINES
+#define CPP_PREDEFINES "\
+-Dunix -Darm26 -D__arm26__ -D__arm__ -D__NetBSD__ -D__ELF__ \
+-Asystem(unix) -Asystem(NetBSD) -Acpu(arm) -Amachine(arm)"
+
+/* Define _POSIX_SOURCE if necessary.  */
+#undef CPP_SPEC
+#define CPP_SPEC "\
+%(cpp_cpu_arch) %(cpp_apcs_pc) %(cpp_float) %(cpp_endian) \
+%{posix:-D_POSIX_SOURCE} \
+"
+
+/* Because TARGET_DEFAULT sets ARM_FLAG_SOFT_FLOAT */
+#undef CPP_FLOAT_DEFAULT_SPEC
+#define CPP_FLOAT_DEFAULT_SPEC "-D__SOFTFP__"
+
+/* Pass -X to the linker so that it will strip symbols starting with 'L' */
+#undef LINK_SPEC
+#define LINK_SPEC \
+ "-X \
+  %{assert*} \
+  %{shared:-shared} \
+  %{!shared: \
+    -dc -dp \
+    %{!nostdlib:%{!r*:%{!e*:-e __start}}} \
+    %{!static: \
+      %{rdynamic:-export-dynamic} \
+      %{!dynamic-linker:-dynamic-linker /usr/libexec/ld.elf_so}} \
+    %{static:-static}}"
+
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "int"
+
+#undef WCHAR_UNSIGNED
+#define WCHAR_UNSIGNED 0
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE 32
+
+#define HANDLE_SYSV_PRAGMA
+
+/* We don't have any limit on the length as out debugger is GDB.  */
+#undef DBX_CONTIN_LENGTH
+
+/* NetBSD does its profiling differently to the Acorn compiler. We
+   don't need a word following the mcount call; and to skip it
+   requires either an assembly stub or use of fomit-frame-pointer when
+   compiling the profiling functions.  Since we break Acorn CC
+   compatibility below a little more won't hurt.  */
+
+#undef FUNCTION_PROFILER
+#define FUNCTION_PROFILER(STREAM,LABELNO)  				    \
+{									    \
+  fprintf(STREAM, "\tmov\t%sip, %slr\n", REGISTER_PREFIX, REGISTER_PREFIX); \
+  fprintf(STREAM, "\tbl\t__mcount\n");					    \
+}
+
+/* On the ARM `@' introduces a comment, so we must use something else
+   for .type directives.  */
+#undef TYPE_OPERAND_FMT
+#define TYPE_OPERAND_FMT "%%%s"
