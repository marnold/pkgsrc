$NetBSD: patch-arm32,v 1.1.1.1 1999/12/06 09:38:35 sakamoto Exp $

diff -U2 -r -N ./bfd/Makefile.am ../binutils-2.9.1/bfd/Makefile.am
--- ./bfd/Makefile.am	Sat May  2 00:47:58 1998
+++ ../binutils-2.9.1/bfd/Makefile.am	Sat Dec  4 02:21:59 1999
@@ -106,4 +106,6 @@
 	aout0.lo \
 	aout32.lo \
+	aoutarm32.lo \
+	armnetbsd.lo \
 	bout.lo \
 	cf-i386lynx.lo \
@@ -211,4 +213,6 @@
 	aout0.c \
 	aout32.c \
+	aoutarm32.c \
+	armnetbsd.c \
 	bout.c \
 	cf-i386lynx.c \
@@ -659,4 +663,7 @@
   $(INCDIR)/aout/aout64.h $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def \
   $(INCDIR)/aout/ar.h
+armnetbsd.lo: armnetbsd.c netbsd.h libaout.h $(INCDIR)/bfdlink.h \
+  aout-target.h $(INCDIR)/aout/aout64.h $(INCDIR)/aout/stab_gnu.h \
+  $(INCDIR)/aout/stab.def $(INCDIR)/aout/ar.h
 bout.lo: bout.c $(INCDIR)/bfdlink.h genlink.h $(INCDIR)/bout.h \
   $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def libaout.h
diff -U2 -r -N ./bfd/Makefile.in ../binutils-2.9.1/bfd/Makefile.in
--- ./bfd/Makefile.in	Sat May  2 00:47:59 1998
+++ ../binutils-2.9.1/bfd/Makefile.in	Sat Dec  4 02:21:59 1999
@@ -195,4 +195,6 @@
 	aout0.lo \
 	aout32.lo \
+	aoutarm32.lo \
+	armnetbsd.lo \
 	bout.lo \
 	cf-i386lynx.lo \
@@ -300,4 +302,6 @@
 	aout0.c \
 	aout32.c \
+	aoutarm32.c \
+	armnetbsd.c \
 	bout.c \
 	cf-i386lynx.c \
@@ -1116,4 +1120,7 @@
   $(INCDIR)/aout/aout64.h $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def \
   $(INCDIR)/aout/ar.h
+armnetbsd.lo: armnetbsd.c netbsd.h libaout.h $(INCDIR)/bfdlink.h \
+  aout-target.h $(INCDIR)/aout/aout64.h $(INCDIR)/aout/stab_gnu.h \
+  $(INCDIR)/aout/stab.def $(INCDIR)/aout/ar.h
 bout.lo: bout.c $(INCDIR)/bfdlink.h genlink.h $(INCDIR)/bout.h \
   $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def libaout.h
diff -U2 -r -N ./bfd/aoutarm32.c ../binutils-2.9.1/bfd/aoutarm32.c
--- ./bfd/aoutarm32.c	Thu Jan  1 09:00:00 1970
+++ ../binutils-2.9.1/bfd/aoutarm32.c	Sat Dec  4 02:21:59 1999
@@ -0,0 +1,504 @@
+/* BFD back-end for 32-bit a.out files.
+   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.
+   Written by Cygnus Support.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#define FPRINTF(x)
+
+#ifndef FPRINTF
+#define FPRINTF(x)	fprintf x
+#endif
+
+#define	N_HEADER_IN_TEXT(x)	1
+
+#include <stdio.h>
+
+#define ARCH_SIZE 32
+
+#define BYTES_IN_WORD	4
+
+#include "bfd.h"
+#include "aout/aout64.h"
+
+#define MY(op)	CAT(aoutarm_,op)
+#define NAME(x, y)	CAT3(aoutarm,_32_,y)
+
+#include "libaout.h"
+
+static bfd_reloc_status_type
+MY(fix_pcrel_26_done)	PARAMS ((bfd *, arelent *, asymbol *, PTR,
+				 asection *, bfd *, char **));
+
+static bfd_reloc_status_type
+MY(fix_pcrel_26)	 PARAMS ((bfd *, arelent *, asymbol *, PTR,
+				  asection *, bfd *, char **));
+
+#define MY_swap_std_reloc_in MY(swap_std_reloc_in)
+#define MY_swap_std_reloc_out MY(swap_std_reloc_out)
+
+static void
+MY_swap_std_reloc_in PARAMS ((bfd *abfd, struct reloc_std_external *bytes,
+			      arelent *cache_ptr, asymbol **symbols,
+			      bfd_size_type symcount));
+
+static void
+MY_swap_std_reloc_out PARAMS ((bfd *abfd, arelent *g,
+			       struct reloc_std_external *natptr));
+
+reloc_howto_type MY(howto_table)[] =
+{
+  /* type rs size bsz pcrel bitpos ovrf sf name part_inpl readmask setmask
+     pcdone */
+  HOWTO (0, 0, 0, 8, false, 0, complain_overflow_bitfield, 0, "8", true,
+	 0x000000ff, 0x000000ff, false),
+  HOWTO (1, 0, 1, 16, false, 0, complain_overflow_bitfield, 0, "16", true,
+	 0x0000ffff, 0x0000ffff, false),
+  HOWTO (2, 0, 2, 32, false, 0, complain_overflow_bitfield, 0, "32", true,
+	 0xffffffff, 0xffffffff, false),
+  HOWTO (3, 2, 2, 26, true, 0, complain_overflow_signed, MY(fix_pcrel_26),
+	 "ARM26", true, 0x00ffffff, 0x00ffffff, true),
+  HOWTO (4, 0, 0, 8, true, 0, complain_overflow_signed, 0, "DISP8", true,
+	 0x000000ff, 0x000000ff, true),
+  HOWTO (5, 0, 1, 16, true, 0, complain_overflow_signed, 0, "DISP16", true,
+	 0x0000ffff, 0x0000ffff, true),
+  HOWTO (6, 0, 2, 32, true, 0, complain_overflow_signed, 0, "DISP32", true,
+	 0xffffffff, 0xffffffff, true),
+  HOWTO (7, 2, 2, 26, false, 0, complain_overflow_signed,
+	 MY(fix_pcrel_26_done), "ARM26D", true, 0x0, 0x0,
+	 false),
+  {-1},
+  HOWTO (9, 0, -1, 16, false, 0, complain_overflow_bitfield, 0, "NEG16", true,
+	 0x0000ffff, 0x0000ffff, false),
+  HOWTO (10, 0, -2, 32, false, 0, complain_overflow_bitfield, 0, "NEG32", true,
+	 0xffffffff, 0xffffffff, false),
+  {-1},
+  {-1},
+  {-1},
+  {-1},
+  {-1},
+
+  {-1},
+  HOWTO (17, 0, 1, 16, false, 0, complain_overflow_bitfield, 0, "GOT12", true,
+	 0x00000fff, 0x00000fff, false),
+  HOWTO (18, 0, 2, 32, false, 0, complain_overflow_bitfield, 0, "GOT32", true,
+	 0xffffffff, 0xffffffff, false),
+  HOWTO (19, 0, 2, 26, true, 0, complain_overflow_bitfield, MY(fix_pcrel_26), "JMPSLOT", true,
+	 0x00ffffff, 0x00ffffff, true),
+
+  {-1},
+  {-1},
+  HOWTO (22, 0, 2, 32, true, 0, complain_overflow_bitfield, 0, "GOTPC", true,
+	 0xffffffff, 0xffffffff, true),
+  {-1},
+
+  {-1},
+  {-1},
+  {-1},
+  {-1},
+  {-1},
+  {-1},
+  {-1},
+  {-1},
+};
+
+#define RELOC_ARM_BITS_NEG_BIG      ((unsigned int) 0x08)
+#define RELOC_ARM_BITS_NEG_LITTLE   ((unsigned int) 0x10)
+#define RELOC_ARM_BITS_PIC_BIG      ((unsigned int) 0x04)
+#define RELOC_ARM_BITS_PIC_LITTLE   ((unsigned int) 0x20)
+
+reloc_howto_type *
+MY(reloc_howto)(abfd, rel, r_index, r_extern, r_pcrel)
+     bfd *abfd;
+     struct reloc_std_external *rel;
+     int *r_index;
+     int *r_extern;
+     int *r_pcrel;
+{
+  unsigned int r_length;
+  unsigned int r_pcrel_done;
+  unsigned int r_neg;
+  unsigned int r_pic;
+  int index;
+
+FPRINTF((stderr, "%s:reloc_howto", __FILE__));
+
+  *r_pcrel = 0;
+  if (bfd_header_big_endian (abfd))
+    {
+      *r_index     =  ((rel->r_index[0] << 16)
+		       | (rel->r_index[1] << 8)
+		       | rel->r_index[2]);
+      *r_extern    = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
+      r_pcrel_done = (0 != (rel->r_type[0] & RELOC_STD_BITS_PCREL_BIG));
+      r_neg 	   = (0 != (rel->r_type[0] & RELOC_ARM_BITS_NEG_BIG));
+      r_pic 	   = (0 != (rel->r_type[0] & RELOC_ARM_BITS_PIC_BIG));
+      r_length     = ((rel->r_type[0] & RELOC_STD_BITS_LENGTH_BIG)
+		      >> RELOC_STD_BITS_LENGTH_SH_BIG);
+    }
+  else
+    {
+      *r_index     = ((rel->r_index[2] << 16)
+		      | (rel->r_index[1] << 8)
+		      | rel->r_index[0]);
+      *r_extern    = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_LITTLE));
+      r_pcrel_done = (0 != (rel->r_type[0] & RELOC_STD_BITS_PCREL_LITTLE));
+      r_neg 	   = (0 != (rel->r_type[0] & RELOC_ARM_BITS_NEG_LITTLE));
+      r_pic 	   = (0 != (rel->r_type[0] & RELOC_ARM_BITS_PIC_LITTLE));
+      r_length     = ((rel->r_type[0] & RELOC_STD_BITS_LENGTH_LITTLE)
+		      >> RELOC_STD_BITS_LENGTH_SH_LITTLE);
+    }
+  index = r_length + 4 * r_pcrel_done + 8 * r_neg + 16 * r_pic;
+  if (index == 3)
+    *r_pcrel = 1;        
+  if (index == 19)	/* jmpslot */
+    *r_pcrel = 1;        
+FPRINTF((stderr, " index=%d name=%s\n", index, (MY(howto_table) + index)->name));
+  return MY(howto_table) + index;
+}
+ 
+#define MY_reloc_howto(BFD, REL, IN, EX, PC) \
+	MY(reloc_howto) (BFD, REL, &IN, &EX, &PC)
+
+void
+MY(put_reloc)(abfd, r_extern, r_index, value, howto, reloc)
+     bfd *abfd;
+     int r_extern;
+     int r_index;
+     long value;
+     reloc_howto_type *howto;
+     struct reloc_std_external *reloc;
+{
+  unsigned int r_length;
+  int r_pcrel;
+  int r_neg;
+  int r_pic;
+
+FPRINTF((stderr, "%s:put_reloc\n", __FILE__));
+
+  PUT_WORD (abfd, value, reloc->r_address);
+  r_length = howto->size ;	/* Size as a power of two */
+
+  /* Special case for branch relocations. */
+  if (howto->type == 3 || howto->type == 7)
+    r_length = 3;
+  if (howto->type == 19)
+    r_length = 3;
+
+  r_pcrel  = howto->type & 4; 	/* PC Relative done? */
+  r_neg = howto->type & 8;	/* Negative relocation */
+  r_pic = howto->type & 16;	/* PIC relocation */
+  if (bfd_header_big_endian (abfd))
+    {
+      reloc->r_index[0] = r_index >> 16;
+      reloc->r_index[1] = r_index >> 8;
+      reloc->r_index[2] = r_index;
+      reloc->r_type[0] =
+	((r_extern ?     RELOC_STD_BITS_EXTERN_BIG : 0)
+	 | (r_pcrel ?    RELOC_STD_BITS_PCREL_BIG : 0)
+	 | (r_neg ?	 RELOC_ARM_BITS_NEG_BIG : 0)
+         | (r_pic ?	 RELOC_ARM_BITS_PIC_BIG : 0)
+	 | (r_length <<  RELOC_STD_BITS_LENGTH_SH_BIG));
+    }
+  else
+    {
+      reloc->r_index[2] = r_index >> 16;
+      reloc->r_index[1] = r_index >> 8;
+      reloc->r_index[0] = r_index;
+      reloc->r_type[0] =
+	((r_extern ?     RELOC_STD_BITS_EXTERN_LITTLE : 0)
+	 | (r_pcrel ?    RELOC_STD_BITS_PCREL_LITTLE : 0)
+	 | (r_neg ?	 RELOC_ARM_BITS_NEG_LITTLE : 0)
+         | (r_pic ?	 RELOC_ARM_BITS_PIC_LITTLE : 0)
+	 | (r_length <<  RELOC_STD_BITS_LENGTH_SH_LITTLE));
+    }
+}
+ 
+#define MY_put_reloc(BFD, EXT, IDX, VAL, HOWTO, RELOC) \
+  MY(put_reloc)(BFD, EXT, IDX, VAL, HOWTO, RELOC)
+
+#include "aoutx.h"
+
+reloc_howto_type *
+MY(bfd_reloc_type_lookup)(abfd,code)
+     bfd *abfd;
+     bfd_reloc_code_real_type code;
+{
+FPRINTF((stderr, "%s:bfd_reloc_type_lookup code=%d\n", __FILE__, (int)code));
+
+#define ASTD(i,j)       case i: FPRINTF((stderr, "i=%d j=%d\n", i,j)); return &MY(howto_table)[j]
+  if (code == BFD_RELOC_CTOR)
+    switch (bfd_get_arch_info (abfd)->bits_per_address)
+      {
+      case 32:
+        code = BFD_RELOC_32;
+        break;
+      default: return (CONST struct reloc_howto_struct *) 0;
+      }
+
+  switch (code)
+    {
+      ASTD (BFD_RELOC_16, 1);
+      ASTD (BFD_RELOC_32, 2);
+      ASTD (BFD_RELOC_ARM_PCREL_BRANCH, 3);
+      ASTD (BFD_RELOC_8_PCREL, 4);
+      ASTD (BFD_RELOC_16_PCREL, 5);
+      ASTD (BFD_RELOC_32_PCREL, 6);
+      ASTD (BFD_RELOC_ARM_GOT12, 17);
+      ASTD (BFD_RELOC_ARM_GOT32, 18);
+      ASTD (BFD_RELOC_ARM_GOTPC, 22);
+      ASTD (BFD_RELOC_ARM_JMPSLOT, 19);
+    default: return (CONST struct reloc_howto_struct *) 0;
+    }
+}
+
+static bfd_reloc_status_type
+MY(fix_pcrel_26) (abfd, reloc_entry, symbol, data, input_section,
+		       output_bfd, error_message)
+     bfd *abfd;
+     arelent *reloc_entry;
+     asymbol *symbol;
+     PTR data;
+     asection *input_section;
+     bfd *output_bfd;
+     char **error_message;
+{
+  bfd_vma relocation;
+  bfd_size_type addr = reloc_entry->address;
+  long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
+  bfd_reloc_status_type flag = bfd_reloc_ok;
+
+FPRINTF((stderr, "%s:fix_pcrel_26\n", __FILE__));
+FPRINTF((stderr, "reloc: target=%x sym->val=%x sym->vma=%x sym->off=%x\n", target, symbol->value, symbol->section->output_section->vma, symbol->section->output_offset));
+FPRINTF((stderr, "reloc: addend=%x ins->vma=%x ins->off=%x addr=%x\n", reloc_entry->addend, input_section->output_section->vma, input_section->output_offset, addr));
+
+  /* If this is an undefined symbol, return error */
+  if (symbol->section == &bfd_und_section
+      && (symbol->flags & BSF_WEAK) == 0)
+    return output_bfd ? bfd_reloc_ok : bfd_reloc_undefined;
+
+  /* If the sections are different, and we are doing a partial relocation,
+     just ignore it for now.  */
+  if (symbol->section->name != input_section->name
+      && output_bfd != (bfd *)NULL)
+    return bfd_reloc_ok;
+
+FPRINTF((stderr, "doing relocation\n"));
+
+  relocation = (target & 0x00ffffff) << 2;
+  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend */
+  relocation += symbol->value;
+  relocation += symbol->section->output_section->vma;
+  relocation += symbol->section->output_offset;
+  relocation += reloc_entry->addend;
+  relocation -= input_section->output_section->vma;
+  relocation -= input_section->output_offset;
+  relocation -= addr;
+  if (relocation & 3)
+    return bfd_reloc_overflow;
+
+  /* Check for overflow */
+  if (relocation & 0x02000000)
+    {
+      if ((relocation & ~0x03ffffff) != ~0x03ffffff)
+	flag = bfd_reloc_overflow;
+    }
+  else if (relocation & ~0x03ffffff)
+    flag = bfd_reloc_overflow;
+
+  target &= ~0x00ffffff;
+  target |= (relocation >> 2) & 0x00ffffff;
+  bfd_put_32 (abfd, target, (bfd_byte *) data + addr);
+
+  /* Now the ARM magic... Change the reloc type so that it is marked as done.
+     Strictly this is only necessary if we are doing a partial relocation.  */
+  reloc_entry->howto = &MY(howto_table)[7];
+  
+  return flag;
+}
+
+static bfd_reloc_status_type
+MY(fix_pcrel_26_done) (abfd, reloc_entry, symbol, data, input_section,
+		       output_bfd, error_message)
+     bfd *abfd;
+     arelent *reloc_entry;
+     asymbol *symbol;
+     PTR data;
+     asection *input_section;
+     bfd *output_bfd;
+     char **error_message;
+{
+  bfd_size_type addr = reloc_entry->address;
+  long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
+
+FPRINTF((stderr, "%s:fix_pcrel_26_done\n", __FILE__));
+FPRINTF((stderr, "reloc: target=%x sym->val=%x sym->vma=%x sym->off=%x\n", target, symbol->value, symbol->section->output_section->vma, symbol->section->output_offset));
+FPRINTF((stderr, "reloc: addend=%x ins->vma=%x ins->off=%x addr=%x\n", reloc_entry->addend, input_section->output_section->vma, input_section->output_offset, addr));
+  return bfd_reloc_ok;
+}
+
+static void
+MY_swap_std_reloc_in (abfd, bytes, cache_ptr, symbols, symcount)
+     bfd *abfd;
+     struct reloc_std_external *bytes;
+     arelent *cache_ptr;
+     asymbol **symbols;
+     bfd_size_type symcount;
+{
+  int r_index;
+  int r_extern;
+  unsigned int r_length;
+  int r_pcrel;
+  struct aoutdata *su = &(abfd->tdata.aout_data->a);
+
+  FPRINTF((stderr, "%s:swap_std_reloc_in\n", __FILE__));
+
+  cache_ptr->address = bfd_h_get_32 (abfd, bytes->r_address);
+
+  cache_ptr->howto = MY_reloc_howto (abfd, bytes, r_index, r_extern, r_pcrel);
+
+  FPRINTF((stderr, "%s:swap_std_reloc_in: type=%d name=%s\n", __FILE__, cache_ptr->howto->type, cache_ptr->howto->name));
+
+  MOVE_ADDRESS (0);
+}
+
+void
+MY_swap_std_reloc_out (abfd, g, natptr)
+     bfd *abfd;
+     arelent *g;
+     struct reloc_std_external *natptr;
+{
+  int r_index;
+  asymbol *sym = *(g->sym_ptr_ptr);
+  int r_extern;
+  int r_length;
+  int r_pcrel;
+  int r_neg = 0;	/* Negative relocs use the BASEREL bit.  */
+  int r_pic = 0;
+  asection *output_section = sym->section->output_section;
+
+  FPRINTF((stderr, "%s:swap_std_reloc_out type=%d name=%s: ga=%x na=%x", __FILE__, g->howto->type, g->howto->name, g->address, natptr->r_address));
+
+  PUT_WORD(abfd, g->address, natptr->r_address);
+
+  r_length = g->howto->size ;   /* Size as a power of two */
+  if (r_length < 0)
+    {
+      r_length = -r_length;
+      r_neg = 1;
+    }
+
+  r_pcrel  = (int) g->howto->pc_relative; /* Relative to PC? */
+
+  /* For RISC iX, in pc-relative relocs the r_pcrel bit means that the
+     relocation has been done already (Only for the 26-bit one I think)???!!!
+     */
+
+  if (g->howto->type == 3)
+    {
+      r_length = 3;
+      r_pcrel = 0;
+    }
+  else if (g->howto->type == 7)
+    { 
+      r_length = 3;
+      r_pcrel = 1;
+    }
+
+  /* Are we base relative i.e. PIC */
+  if (g->howto->type >= 16)
+    r_pic = 1;
+
+  /* jmpslot (branch with pic set) - treat like a branch */
+  if (g->howto->type == 19) {
+      r_length = 3;
+      r_pcrel = 0;
+     }
+#if 0
+  /* For a standard reloc, the addend is in the object file.  */
+  r_addend = g->addend + (*(g->sym_ptr_ptr))->section->output_section->vma;
+#endif
+
+  /* name was clobbered by aout_write_syms to be symbol index */
+
+  /* If this relocation is relative to a symbol then set the
+     r_index to the symbols index, and the r_extern bit.
+
+     Absolute symbols can come in in two ways, either as an offset
+     from the abs section, or as a symbol which has an abs value.
+     check for that here
+     */
+
+  if (bfd_is_com_section (output_section)
+      || output_section == &bfd_abs_section
+      || output_section == &bfd_und_section)
+    {
+      if (bfd_abs_section.symbol == sym)
+	{
+	  /* Whoops, looked like an abs symbol, but is really an offset
+	     from the abs section */
+	  r_index = 0;
+	  r_extern = 0;
+	}
+      else
+	{
+	  /* Fill in symbol */
+	  r_extern = 1;
+	  r_index = (*(g->sym_ptr_ptr))->KEEPIT;
+	}
+    }
+  else
+    {
+      /* Just an ordinary section */
+      r_extern = 0;
+        r_index  = output_section->target_index;
+      if (r_pic && g->howto->type == 18) {
+	r_index = (*(g->sym_ptr_ptr))->KEEPIT;
+/*	r_extern = 1;*/	/*260697*/
+	if (sym->flags & BSF_GLOBAL)
+		r_extern = 1;
+	FPRINTF((stderr, "*"));
+      }
+    }
+FPRINTF((stderr, " index=%d\n", r_index));
+  /* now the fun stuff */
+  if (bfd_header_big_endian (abfd))
+    {
+      natptr->r_index[0] = r_index >> 16;
+      natptr->r_index[1] = r_index >> 8;
+      natptr->r_index[2] = r_index;
+      natptr->r_type[0] =
+	(  (r_extern ?   RELOC_STD_BITS_EXTERN_BIG: 0)
+	 | (r_pcrel  ?   RELOC_STD_BITS_PCREL_BIG: 0)
+	 | (r_neg    ?   RELOC_ARM_BITS_NEG_BIG: 0)
+	 | (r_pic    ?   RELOC_ARM_BITS_PIC_BIG: 0)
+	 | (r_length <<  RELOC_STD_BITS_LENGTH_SH_BIG));
+    }
+  else
+    {
+      natptr->r_index[2] = r_index >> 16;
+      natptr->r_index[1] = r_index >> 8;
+      natptr->r_index[0] = r_index;
+      natptr->r_type[0] =
+	(  (r_extern ?   RELOC_STD_BITS_EXTERN_LITTLE: 0)
+	 | (r_pcrel  ?   RELOC_STD_BITS_PCREL_LITTLE: 0)
+	 | (r_neg    ?   RELOC_ARM_BITS_NEG_LITTLE: 0)
+	 | (r_pic    ?   RELOC_ARM_BITS_PIC_LITTLE: 0)
+	 | (r_length <<  RELOC_STD_BITS_LENGTH_SH_LITTLE));
+    }
+}
+
diff -U2 -r -N ./bfd/armnetbsd.c ../binutils-2.9.1/bfd/armnetbsd.c
--- ./bfd/armnetbsd.c	Thu Jan  1 09:00:00 1970
+++ ../binutils-2.9.1/bfd/armnetbsd.c	Sat Dec  4 02:21:59 1999
@@ -0,0 +1,47 @@
+/* BFD back-end for NetBSD/ARM a.out-ish binaries.
+   Copyright (C) 1990, 1991, 1992 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+#define	BYTES_IN_WORD	4
+#undef TARGET_IS_BIG_ENDIAN_P
+
+#define	TARGET_PAGE_SIZE	4096
+#define	SEGMENT_SIZE	TARGET_PAGE_SIZE
+
+#define	DEFAULT_ARCH	bfd_arch_arm
+#define	DEFAULT_MID 	M_ARM6_NETBSD
+/*#define MACHTYPE_OK(mtype) ((mtype) == M_ARM6_NETBSD)*/
+
+#define MY(OP) CAT(armnetbsd_,OP)
+/* This needs to start with a.out so GDB knows it is an a.out variant.  */
+#define TARGETNAME "a.out-arm-netbsd"
+
+#define NAME(x,y) CAT3(aoutarm,_32_,y)
+
+#define aoutarm_32_get_section_contents aout_32_get_section_contents
+
+#define MY_bfd_reloc_type_lookup aoutarm_bfd_reloc_type_lookup
+
+#include "bfd.h"		/* To ensure following declaration is OK */
+
+CONST struct reloc_howto_struct *
+MY_bfd_reloc_type_lookup
+  PARAMS((bfd *abfd AND
+	  bfd_reloc_code_real_type code));
+
+#include "netbsd.h"
diff -U2 -r -N ./bfd/bfd-in2.h ../binutils-2.9.1/bfd/bfd-in2.h
--- ./bfd/bfd-in2.h	Sat May  2 00:48:01 1998
+++ ../binutils-2.9.1/bfd/bfd-in2.h	Sat Dec  4 02:21:59 1999
@@ -1850,4 +1850,8 @@
   BFD_RELOC_ARM_THUMB_SHIFT,
   BFD_RELOC_ARM_THUMB_OFFSET,
+  BFD_RELOC_ARM_GOTPC,
+  BFD_RELOC_ARM_GOT12,
+  BFD_RELOC_ARM_GOT32,
+  BFD_RELOC_ARM_JMPSLOT,
 
 /* Hitachi SH relocs.  Not all of these appear in object files. */
diff -U2 -r -N ./bfd/config.bfd ../binutils-2.9.1/bfd/config.bfd
--- ./bfd/config.bfd	Sat Dec  4 02:20:13 1999
+++ ../binutils-2.9.1/bfd/config.bfd	Sat Dec  4 02:21:59 1999
@@ -83,5 +83,8 @@
     targ_selvecs=bfd_elf32_bigarc_vec
     ;;
-
+  arm-*-netbsd*)
+    targ_defvec=armnetbsd_vec
+    targ_underscore=yes
+    ;;
   arm-*-riscix*)
     targ_defvec=riscix_vec
diff -U2 -r -N ./bfd/configure ../binutils-2.9.1/bfd/configure
--- ./bfd/configure	Sat Dec  4 02:20:12 1999
+++ ../binutils-2.9.1/bfd/configure	Sat Dec  4 02:21:59 1999
@@ -2704,4 +2704,5 @@
     armcoff_little_vec)		tb="$tb coff-arm.lo cofflink.lo " ;;
     armcoff_big_vec)		tb="$tb coff-arm.lo cofflink.lo " ;;
+    armnetbsd_vec)		tb="$tb armnetbsd.lo aoutarm32.lo " ;;
     armpe_little_vec)		tb="$tb pe-arm.lo coff-arm.lo cofflink.lo " ;;
     armpe_big_vec)		tb="$tb pe-arm.lo coff-arm.lo cofflink.lo " ;;
diff -U2 -r -N ./bfd/configure.in ../binutils-2.9.1/bfd/configure.in
--- ./bfd/configure.in	Sat May  2 00:48:05 1998
+++ ../binutils-2.9.1/bfd/configure.in	Sat Dec  4 02:21:59 1999
@@ -388,4 +388,5 @@
     armcoff_little_vec)		tb="$tb coff-arm.lo cofflink.lo " ;;
     armcoff_big_vec)		tb="$tb coff-arm.lo cofflink.lo " ;;
+    armnetbsd_vec)		tb="$tb armnetbsd.lo aoutarm32.lo " ;;
     armpe_little_vec)		tb="$tb pe-arm.lo coff-arm.lo cofflink.lo " ;;
     armpe_big_vec)		tb="$tb pe-arm.lo coff-arm.lo cofflink.lo " ;;
diff -U2 -r -N ./bfd/libaout.h ../binutils-2.9.1/bfd/libaout.h
--- ./bfd/libaout.h	Sat May  2 00:48:11 1998
+++ ../binutils-2.9.1/bfd/libaout.h	Sat Dec  4 02:21:59 1999
@@ -233,4 +233,5 @@
   M_VAX_NETBSD = 140,	/* NetBSD/vax binary */
   M_ALPHA_NETBSD = 141,	/* NetBSD/alpha binary */
+  M_ARM6_NETBSD = 143,  /* NetBSD/arm32 binary */
   M_SPARCLET_1 = 147,	/* 0x93, reserved */
   M_MIPS1 = 151,        /* MIPS R2000/R3000 binary */
diff -U2 -r -N ./bfd/reloc.c ../binutils-2.9.1/bfd/reloc.c
--- ./bfd/reloc.c	Sat May  2 00:48:14 1998
+++ ../binutils-2.9.1/bfd/reloc.c	Sat Dec  4 02:21:59 1999
@@ -2167,4 +2167,12 @@
 ENUMX
   BFD_RELOC_ARM_THUMB_OFFSET
+ENUMX
+  BFD_RELOC_ARM_GOTPC
+ENUMX
+  BFD_RELOC_ARM_GOT12
+ENUMX
+  BFD_RELOC_ARM_GOT32
+ENUMX
+  BFD_RELOC_ARM_JMPSLOT
 ENUMDOC
   These relocs are only used within the ARM assembler.  They are not
diff -U2 -r -N ./bfd/targets.c ../binutils-2.9.1/bfd/targets.c
--- ./bfd/targets.c	Sat Dec  4 02:20:12 1999
+++ ../binutils-2.9.1/bfd/targets.c	Sat Dec  4 02:21:59 1999
@@ -482,4 +482,5 @@
 extern const bfd_target armpei_little_vec;
 extern const bfd_target armpei_big_vec;
+extern const bfd_target armnetbsd_vec;
 extern const bfd_target b_out_vec_big_host;
 extern const bfd_target b_out_vec_little_host;
@@ -737,4 +738,5 @@
 	&armpei_little_vec,
 	&armpei_big_vec,
+	&armnetbsd_vec,
 	&icoff_big_vec,
 	&icoff_little_vec,
diff -U2 -r -N ./ld/Makefile.am ../binutils-2.9.1/ld/Makefile.am
--- ./ld/Makefile.am	Sat May  2 00:48:47 1998
+++ ../binutils-2.9.1/ld/Makefile.am	Sat Dec  4 02:22:08 1999
@@ -99,4 +99,5 @@
 	earmaoutl.o \
 	earmcoff.o \
+	earmnbsd.o \
 	earmpe.o \
 	ecoff_sparc.o \
@@ -254,4 +255,7 @@
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armcoff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} armcoff "$(tdir_armcoff)"
+earmnbsd.c:	$(srcdir)/emulparams/armnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armnbsd "$(tdir_armnbsd)"
 earmpe.c: $(srcdir)/emulparams/armpe.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
diff -U2 -r -N ./ld/Makefile.in ../binutils-2.9.1/ld/Makefile.in
--- ./ld/Makefile.in	Sat Dec  4 02:20:12 1999
+++ ../binutils-2.9.1/ld/Makefile.in	Sat Dec  4 02:22:08 1999
@@ -175,4 +175,5 @@
 	earmaoutl.o \
 	earmcoff.o \
+	earmnbsd.o \
 	earmpe.o \
 	ecoff_sparc.o \
@@ -764,4 +765,7 @@
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armcoff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} armcoff "$(tdir_armcoff)"
+earmnbsd.c:	$(srcdir)/emulparams/armnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armnbsd "$(tdir_armnbsd)"
 earmpe.c: $(srcdir)/emulparams/armpe.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
diff -U2 -r -N ./ld/configure.tgt ../binutils-2.9.1/ld/configure.tgt
--- ./ld/configure.tgt	Sat May  2 00:48:48 1998
+++ ../binutils-2.9.1/ld/configure.tgt	Sat Dec  4 02:22:08 1999
@@ -106,4 +106,5 @@
 armeb-*-aout)		targ_emul=armaoutb ;;
 arm-*-coff)		targ_emul=armcoff ;;
+arm-*-netbsd*)		targ_emul=armnbsd ;;
 thumb-*-coff)		targ_emul=armcoff ;;
 thumb-*-pe)		targ_emul=armpe ;;
diff -U2 -r -N ./ld/emulparams/armnbsd.sh ../binutils-2.9.1/ld/emulparams/armnbsd.sh
--- ./ld/emulparams/armnbsd.sh	Thu Jan  1 09:00:00 1970
+++ ../binutils-2.9.1/ld/emulparams/armnbsd.sh	Sat Dec  4 02:22:08 1999
@@ -0,0 +1,7 @@
+SCRIPT_NAME=aout
+TEXT_START_ADDR=0x1020
+OUTPUT_FORMAT="a.out-arm-netbsd"
+TARGET_PAGE_SIZE=0x1000
+ARCH=arm
+EXECUTABLE_SYMBOLS='__DYNAMIC = 0;'
+NONPAGED_TEXT_START_ADDR=0x1000
diff -U2 -r -N ./gas/config/tc-arm.c ../binutils-2.9.1/gas/config/tc-arm.c
--- ./gas/config/tc-arm.c	Sat May  2 00:44:39 1998
+++ ../binutils-2.9.1/gas/config/tc-arm.c	Sat Dec  4 02:56:53 1999
@@ -33,4 +33,8 @@
 #include "listing.h"
 
+/* Parser fixup to handle complicated __GLOBAL_OFFSET_TABLE_ expressions */
+#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES)\
+	parse_cons_expression_arm(EXP)
+
 /* ??? This is currently unused.  */
 #ifdef __STDC__
@@ -88,4 +92,6 @@
 static unsigned long	cpu_variant = CPU_DEFAULT | FPU_DEFAULT;
 
+static boolean		pic_code = false;
+
 #ifdef OBJ_COFF
 /* Flags stored in private area of BFD COFF structure */
@@ -93,5 +99,4 @@
 static boolean		support_interwork = false;
 static boolean		uses_apcs_float = false;
-static boolean		pic_code = false;
 #endif
 
@@ -864,4 +869,8 @@
 static void s_force_thumb PARAMS ((int));
 static void s_thumb_func PARAMS ((int));
+static void s_cons PARAMS ((int));
+static void s_type PARAMS ((int));
+static void s_weak PARAMS ((int));
+static void s_size PARAMS ((int));
 
 static int my_get_expression PARAMS ((expressionS *, char **));
@@ -880,8 +889,13 @@
   {"ltorg", s_ltorg, 0},
   {"pool", s_ltorg, 0},
-  {"word", cons, 4},
+  {"word", s_cons, 4},
   {"extend", float_cons, 'x'},
   {"ldouble", float_cons, 'x'},
   {"packed", float_cons, 'p'},
+  {"type", s_type, 0},
+  {"weak", s_weak, 0},
+#if 0
+  {"size", s_size, 0},
+#endif
   {0, 0, 0}
 };
@@ -5274,4 +5288,8 @@
       break;
 
+    case BFD_RELOC_ARM_GOTPC:
+      md_number_to_chars (buf, value, 4);
+      break;
+
     case BFD_RELOC_ARM_CP_OFF_IMM:
       sign = value >= 0;
@@ -5481,4 +5499,12 @@
 
     case BFD_RELOC_32:
+      if (pic_code && fixp->fx_pcrel == 0 && fixp->fx_addsy != NULL)
+	{
+	  if (section == text_section) 
+	    code = BFD_RELOC_ARM_GOT32;
+	  else
+	    code = fixp->fx_r_type;
+	  break;
+	}
       if (fixp->fx_pcrel)
 	{
@@ -5488,4 +5514,9 @@
 
     case BFD_RELOC_ARM_PCREL_BRANCH:
+      if (pic_code)
+	{
+	  code = BFD_RELOC_ARM_JMPSLOT;
+	  break;
+	}
     case BFD_RELOC_RVA:      
     case BFD_RELOC_THUMB_PCREL_BRANCH9:
@@ -5503,4 +5534,10 @@
       return NULL;
 
+    case BFD_RELOC_ARM_GOTPC:
+      assert(fixp->fx_pcrel != 0);
+      code = fixp->fx_r_type;
+      code = BFD_RELOC_32_PCREL;
+      break;
+
     default:
       {
@@ -5883,5 +5920,5 @@
  */
 
-CONST char *md_shortopts = "m:";
+CONST char *md_shortopts = "m:k";
 struct option md_longopts[] =
 {
@@ -6146,4 +6183,8 @@
       break;
 
+    case 'k':
+      pic_code = 1;
+      break;
+
     default:
       return 0;
@@ -6166,4 +6207,5 @@
 -mfpe-old\t\tdon't allow floating-point multiple instructions\n\
 -mno-fpu\t\tdon't allow any floating-point instructions.\n");
+  fprintf (fp, "-k\t\t\tgenerate PIC code.\n");
 #ifdef OBJ_COFF
   fprintf (fp,
@@ -6340,3 +6382,303 @@
 
   return name;
+}
+
+/* Treat expressions starting __GLOBAL_OFFSET_TABLE_ + as special. Evaluate
+ * RHS first.
+ *
+ * XXX - This is a complete hack. No idea what the *right* way to do this
+ * is.
+ *
+ * This is probably no longer needed with gcc 2.8+
+ */
+void
+parse_cons_expression_arm(exp)
+     expressionS *exp;
+{
+  static const char* got = GLOBAL_OFFSET_TABLE_NAME;
+  static int strlen_got = 0;
+  static char* line_space = NULL; /* Horrible hack because I'm not sure that 
+				     free() is okay to call at the end of 
+				     this fn */
+
+  char *tmp_line_pointer;
+  char *eol_pointer;
+  char *rhs;
+  char *saved_line_pointer;
+  expressionS right;
+  char c;
+  symbolS *symbolP;	/* points to symbol */
+  char *name;		/* points to name of symbol */
+  segT segment;
+
+  if (strlen_got == 0) 
+    strlen_got = strlen(got);
+
+  if (strncmp(input_line_pointer, got, strlen_got) != 0)
+    {
+      /* Not a GOT expression, proceed as normal. */
+      expression(exp);
+      return;
+    }
+  
+  saved_line_pointer = input_line_pointer;
+
+  name = input_line_pointer;
+  c = get_symbol_end();
+  symbolP = symbol_find_or_make (name);
+
+  segment = S_GET_SEGMENT (symbolP);
+  if (segment == undefined_section) 
+    {
+      exp->X_op = O_symbol;
+      exp->X_add_symbol = symbolP;
+      exp->X_add_number = 0;
+    }
+
+  *input_line_pointer = c;
+
+  SKIP_WHITESPACE();
+  if (*input_line_pointer == '+')
+  	++input_line_pointer;
+
+  expression(&right);
+
+  input_line_pointer = saved_line_pointer + strlen_got;
+  SKIP_WHITESPACE();
+
+  if (*input_line_pointer != '+' && *input_line_pointer != '-')
+    {
+      /* Not an operator we can deal with. */
+      input_line_pointer = saved_line_pointer;
+      expression(exp);
+      return;
+    }
+
+  /* Shut your eyes - you don't want to see this bit.
+   * Build a buffer to hold a munged input line and
+   * hand that on to the generic expression parser.
+   */
+
+  rhs = input_line_pointer + 1;
+
+  while (*input_line_pointer != '\n' && *input_line_pointer != '\0' && 
+	 *input_line_pointer != ';')
+    input_line_pointer++;
+  eol_pointer = input_line_pointer;
+
+  if (line_space != NULL) 
+    free (line_space);
+  input_line_pointer = line_space = malloc(eol_pointer - 
+					   saved_line_pointer + 3);
+  strncpy (input_line_pointer, saved_line_pointer, rhs - saved_line_pointer);
+  input_line_pointer[rhs - saved_line_pointer] = '\0';
+  strcat (input_line_pointer, "(");
+  strncat (input_line_pointer, rhs, eol_pointer - rhs);
+  input_line_pointer[eol_pointer - saved_line_pointer + 1] = 0;
+  strcat (input_line_pointer, ")");
+
+  /* Okay, you can open your eyes again now. */
+
+  expression(exp);
+
+/* XXX - Hack to check whether any pointers are left referring to the 
+ * line_space buffer
+ * Note: free() to be moved down here if this turns out to be safe.
+ */
+
+  while(input_line_pointer > line_space)
+    {
+      input_line_pointer--;
+      input_line_pointer[0] = 'X';
+    }
+  *input_line_pointer = '\0';
+
+  /* Restore the input_line_pointer to point to where the caller expects it to be and exit. */
+
+  input_line_pointer = eol_pointer;
+}
+
+/*
+ * Called to deal with an expression part of an .word instruction
+ * i.e.
+ * 	.word <expression>
+ *
+ * This is an expression that could have a GOT reference of the form
+ * __GLOBAL_OFFSET_TABLE + . - (L2 + 4)
+ *
+ * This is something that the expression parser cannot handle
+ * We need to perform the . - (L2 + 4) part first as this resolves
+ * to an absolute.
+ */
+
+static void
+s_cons(size)
+	int size;
+{
+#if 0
+	if (pic_code) 
+	  abort();		/* Whoops */
+#endif
+	cons (size);
+}
+
+/*
+ * This fix_new is called by cons via TC_CONS_FIX_NEW
+ *
+ * We check the expression to see if it is of the form
+ *  __GLOBAL_OFFSET_TABLE + ???
+ * If it is then this is a PC relative reference to the GOT.
+ * i.e.
+ * 	ldr	sl, L1
+ * 	add	sl, pc, sl
+ * L2:
+ * 	...
+ * L1:
+ *	.word	__GLOBAL_OFFSET_TABLE + (. - (L2 + 4))
+ *
+ * In this case use a reloc type BFD_RELOC_ARM_GOTPC instead of the
+ * normal BFD_RELOC_{16,32,64}
+ */
+
+void
+cons_fix_new_arm(frag, where, size, exp)
+	fragS *frag;
+	int where;
+	int size;
+	expressionS *exp;
+{
+	bfd_reloc_code_real_type type;
+	int pcrel = 0;
+
+	/* Pick a reloc ...
+	 *
+	 * @@ Should look at CPU word size.
+	 */
+	switch (size) 
+	  {
+	  case 2:
+	    type = BFD_RELOC_16;
+	    break;
+	  case 4:
+	  default:
+	    type = BFD_RELOC_32;
+	    break;
+	  case 8:
+	    type = BFD_RELOC_64;
+	    break;
+	  }
+	
+	/* Look for possible GOTPC reloc */
+
+	/*
+	 * Look for pic assembler and 'undef symbol + expr symbol' expression
+	 * and a 32 bit size
+	 */
+
+	if (pic_code != 0 && size == 4 && exp->X_op == O_add
+	    && exp->X_add_symbol
+	    && S_GET_SEGMENT (exp->X_add_symbol) == undefined_section
+	    && exp->X_op_symbol
+	    && S_GET_SEGMENT (exp->X_op_symbol) == expr_section) 
+	  {
+	    /*
+	     * This could be it
+	     * Is the primary symbol name "__GLOBAL_OFFSET_TABLE" ?
+	     */
+	    if (strcmp (S_GET_NAME(exp->X_add_symbol),
+		       GLOBAL_OFFSET_TABLE_NAME) == 0) 
+	      {
+		type = BFD_RELOC_ARM_GOTPC;
+		pcrel = 1;
+	      }
+	  }
+	
+	fix_new_exp (frag, where, (int) size, exp, pcrel, type);
+}
+
+#define AUX_OBJECT	1
+#define AUX_FUNCTION	2
+
+static void
+s_type(a)
+	int a;
+{
+  /* Strip out the section name */
+  char *symbol_name, *symbol_name_end;
+  char *type_name, *type_name_end;
+  char c;
+  register symbolS *symbolP;
+  unsigned int len;
+
+  symbol_name = input_line_pointer;
+  c = get_symbol_end ();
+  symbol_name_end = input_line_pointer;
+  input_line_pointer++;
+  len = symbol_name_end - symbol_name;
+
+  SKIP_WHITESPACE ();
+
+  if (c == ',')
+    {
+      /* Allow some leeway here, as .type has used several different 
+	 characters at different times.  `%' is the current favourite
+	 and this is what gcc 2.8 outputs, but `@' is traditional on
+	 other machines and there was a time when `#' got used by some
+	 people.  */
+      if (input_line_pointer[0] == '#' || input_line_pointer[0] == '@'
+	  || input_line_pointer[0] == '%')
+        ++input_line_pointer;
+
+      if (strncmp (input_line_pointer, "object", 6) == 0) 
+	{
+	  symbolP = symbol_find_or_make (symbol_name);
+	  S_SET_OTHER (symbolP, S_GET_OTHER(symbolP) | AUX_OBJECT);
+	  input_line_pointer += 6;
+	} 
+      else 
+	if (strncmp (input_line_pointer, "function", 8) == 0) 
+	  {
+	    symbolP = symbol_find_or_make (symbol_name);
+	    S_SET_OTHER (symbolP, S_GET_OTHER(symbolP) | AUX_FUNCTION);
+	    input_line_pointer += 8;
+	  }
+    }
+
+  demand_empty_rest_of_line ();
+}
+
+#define BIND_WEAK	0x20
+
+static void
+s_weak(a)
+	int a;
+{
+
+  char *name;
+  int c;
+  symbolS *symbolP;
+
+  do
+    {
+      name = input_line_pointer;
+      c = get_symbol_end ();
+      symbolP = symbol_find_or_make (name);
+      *input_line_pointer = c;
+      SKIP_WHITESPACE ();
+      S_SET_OTHER(symbolP, S_GET_OTHER(symbolP) | BIND_WEAK);
+      /*
+       * Anything declared weak becomes global.
+       * Not sure why but this is required to work with the netbsd linker
+       * The NetBSD assembler does this.
+       */
+      if (c == ',')
+	{
+	  input_line_pointer++;
+	  SKIP_WHITESPACE ();
+	  if (*input_line_pointer == '\n')
+	    c = '\n';
+	}
+    }
+  while (c == ',');
+  demand_empty_rest_of_line ();
 }
diff -U2 -r -N ./gas/config/tc-arm.h ../binutils-2.9.1/gas/config/tc-arm.h
--- ./gas/config/tc-arm.h	Sat May  2 00:44:40 1998
+++ ../binutils-2.9.1/gas/config/tc-arm.h	Sat Dec  4 02:56:53 1999
@@ -47,4 +47,6 @@
 #ifdef TE_RISCIX
 #define TARGET_FORMAT "a.out-riscix"
+#elif defined (TE_NetBSD)
+#define TARGET_FORMAT "a.out-arm-netbsd"
 #else
 #define ARM_BI_ENDIAN
@@ -147,4 +149,39 @@
 
 #define LOCAL_LABELS_FB  1
+
+extern boolean pic_code;
+
+/* This expression evaluates to false if the relocation is for a local
+   object for which we still want to do the relocation at runtime.
+   True if we are willing to perform this relocation while building
+   the .o file.
+
+   If the reloc is against an externally visible symbol, then the
+   a.out assembler should not do the relocation if generating PIC */
+
+#define obj_relocate_extern	(!pic_code)
+
+/* This expression evaluates to false if the relocation is for a local object
+   for which we still want to do the relocation at runtime.  True if we
+   are willing to perform this relocation while building the .o file.
+   This is only used for pcrel relocations, so GOTOFF does not need to be
+   checked here.  I am not sure if some of the others are ever used with
+   pcrel, but it is easier to be safe than sorry. */
+
+#define TC_RELOC_RTSYM_LOC_FIXUP(FIX)  \
+   ((FIX)->fx_r_type != BFD_RELOC_ARM_GOT12 \
+   && (FIX)->fx_r_type != BFD_RELOC_ARM_GOT32 \
+   && (FIX)->fx_r_type != BFD_RELOC_32)
+
+#define TC_CONS_FIX_NEW cons_fix_new_arm
+extern void cons_fix_new_arm	PARAMS ((fragS *frag,
+					int where,
+					int size,
+					expressionS *exp));
+
+#define GLOBAL_OFFSET_TABLE_NAME "__GLOBAL_OFFSET_TABLE_"
+
+#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES)\
+	parse_cons_expression_arm(EXP)
 
 /* end of tc-arm.h */
diff -U2 -r -N ./gas/configure ../binutils-2.9.1/gas/configure
--- ./gas/configure	Sat May  2 00:45:07 1998
+++ ../binutils-2.9.1/gas/configure	Sat Dec  4 02:56:53 1999
@@ -1460,4 +1460,5 @@
       arm-*-riscix*)        fmt=aout ;;
       arm-*-pe | thumb-*-pe)               fmt=coff em=pe ;;
+      arm-*-netbsd*)        fmt=aout em=nbsd bfd_gas=yes ;;
 
       d10v-*-*)		    fmt=elf bfd_gas=yes ;;
diff -U2 -r -N ./gas/configure.in ../binutils-2.9.1/gas/configure.in
--- ./gas/configure.in	Sat May  2 00:45:07 1998
+++ ../binutils-2.9.1/gas/configure.in	Sat Dec  4 02:56:53 1999
@@ -134,4 +134,5 @@
       arm-*-riscix*)        fmt=aout ;;
       arm-*-pe | thumb-*-pe)               fmt=coff em=pe ;;
+      arm-*-netbsd*)        fmt=aout em=nbsd bfd_gas=yes ;;
 
       d10v-*-*)		    fmt=elf bfd_gas=yes ;;
