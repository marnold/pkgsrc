$NetBSD: patch-ag,v 1.1.1.1 2002/10/08 14:07:03 martti Exp $

--- lib/kformula/elementindex.h.orig	Sun May 27 15:07:03 2001
+++ lib/kformula/elementindex.h
@@ -30,7 +30,54 @@
 
 class ElementIndex;
 
+#if defined(__GNUC__)
+#if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 93)
+/*
+ * We add a quick 'n' dirty inline implementation of auto_ptr for older
+ * releases of GCC, which don't include an auto_ptr implementation in
+ * <memory>.
+ */
+
+template <class T> class auto_ptr {
+private:
+	T* _ptr;
+
+public:
+	typedef T element_type;
+	explicit auto_ptr(T* p = 0) : _ptr(p) {}
+	auto_ptr(auto_ptr& a) : _ptr(a.release()) {}
+	template <class T1> auto_ptr(auto_ptr<T1>& a) : _ptr(a.release()) {}
+	auto_ptr& operator=(auto_ptr& a) {
+		if (&a != this) {
+			delete _ptr;
+			_ptr = a.release();
+		}
+		return *this;
+	}
+	template <class T1>
+	auto_ptr& operator=(auto_ptr<T1>& a) {
+		if (a.get() != this->get()) {
+			delete _ptr;
+			_ptr = a.release();
+		}
+		return *this;
+	}
+	~auto_ptr() { delete _ptr; }
+
+	T& operator*() const { return *_ptr; }
+	T* operator->() const { return _ptr; }
+	T* get() const { return _ptr; }
+	T* release() { T* tmp = _ptr; _ptr = 0; return tmp; }
+	void reset(T* p = 0) { delete _ptr; _ptr = p; }
+};
+
+typedef auto_ptr<ElementIndex> ElementIndexPtr;
+#else
 typedef std::auto_ptr<ElementIndex> ElementIndexPtr;
+#endif
+#else
+typedef std::auto_ptr<ElementIndex> ElementIndexPtr;
+#endif
 
 
 /**
